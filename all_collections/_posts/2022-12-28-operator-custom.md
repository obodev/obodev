---
layout: post
title: Перегрузка операторов. Пользовательские операторы
date: 2022-12-28
categories: ["Swift", "SPL"]
---

## Перегрузка операторов (Operator Overloading)

После объявления оператора его можно связать с методом типа или функцией верхнего уровня. Когда оператор может разрешать разные функции в зависимости от типов операндов, мы говорим, что оператор перегружен.

Наиболее яркие примеры перегрузки можно найти с оператором `+`. Во многих языках `+` можно использовать для выполнения арифметического сложения (1 + 2 => 3) или конкатенации для массивов и других коллекций ([1] + [2] => [1, 2]).

Разработчики имеют возможность перегружать стандартные операторы, объявляя новую функцию для символа оператора с соответствующим количеством и типом аргументов.

Например, чтобы перегрузить оператор `*` для повторения строки указанное количество раз, вы должны объявить следующую функцию верхнего уровня:

```swift
func * (lhs: String, rhs: Int) -> String {
    guard rhs > 0 else {
        return ""
    }

    return String(repeating: lhs, count: rhs)
}

"hello" * 3 // hellohellohello
```

Рассмотрим следующий пример:

```swift
[1, 2] + [3, 4] // [1, 2, 3, 4]
```

По умолчанию оператор `+` объединяет элементы обоих массивов и реализуется с использованием общего определения функции.

Если бы вы объявили специализированную функцию, которая перегружает `+` для массивов значений `Double` для выполнения сложения по элементам, это переопределило бы предыдущее поведение конкатенации:

```swift
func + (lhs: [Double], rhs: [Double]) -> [Double] {
    return zip(lhs, rhs).map(+)
}

[1.0, 3.0, 5.0] + [2.0, 4.0, 6.0] // [3.0, 7.0, 11.0]
```

В этом заключается проблема перегрузки операторов: неоднозначная семантика.

## Определение пользовательских операторов

Одной из самых захватывающих функций Swift (хотя и спорной) является возможность определять **пользовательские операторы**.

### Объявление операторов

Объявление оператора вводит в вашу программу новый инфиксный, префиксный или постфиксный оператор и объявляется с помощью ключевого слова `operator`.

Можно объявить операторы трех разных обозначений (нотаций): инфикс, префикс и постфикс. Обозначение оператора указывает относительное положение оператора по отношению к его операндам.

Существует три основных формы объявления оператора, по одной для каждого обозначения. Обозначение оператора указывается путем пометки объявления оператора модификатором объявления `infix`, `prefix`, или `postfix` перед ключевым словом `operator`.

```
<notation> operator <operator name>: <precedence group>
```

- `notation` - модификатор объявления оператора `infix`, `prefix`, или `postfix`;
- `operator` - ключевое слово объявления оператора;
- `operator name` - имя оператора, по которому его можно вызвать;
- `precedence group` - имя группы приоритета; Необязательная опция, без указания (по умолчанию) будет DefaultPrecedence.

Следующая форма объявляет новый инфиксный оператор:

```
infix operator <operator name>: <precedence group>
```

Инфиксный оператор — это бинарный оператор, который записывается между двумя его операндами, например известный оператор сложения (`+`) в выражении `1 + 2`.

Инфиксные операторы могут дополнительно указывать группу приоритета. Если не указать группу приоритета для оператора, Swift использует группу приоритета по умолчанию, DefaultPrecedence, которая указывает приоритет чуть выше, чем TernaryPrecedence.

Следующая форма объявляет новый префиксный оператор:

```
prefix operator `operator name`
```

Префиксный оператор — это унарный оператор, который записывается непосредственно перед своим операндом, например, префиксный логический оператор НЕ (`!`) в выражении `!a`.

Объявления префиксных операторов не определяют уровень приоритета. Префиксные операторы неассоциативны.

Следующая форма объявляет новый постфиксный оператор:

```
postfix operator `operator name`
```

Постфиксный оператор — это унарный оператор, который записывается сразу после своего операнда, например, постфиксный оператор принудительного разворачивания опционала (`!`) в выражении `a!`.

Как и в случае с префиксными операторами, объявления постфиксных операторов не определяют уровень приоритета. Постфиксные операторы неассоциативны.

После объявления нового оператора необходимо объявить статический метод с тем же именем, что и у оператора. Статический метод является членом одного из типов, значения которых оператор принимает в качестве аргумента. Например, оператор, умножающий `Double` на `Int`, реализован как статический метод в структуре `Double` или `Int`.

Если реализуете префиксный или постфиксный оператор, также нужно пометить это объявление метода соответствующим модификатором объявления `prefix` или `postfix`.

### Объявление группы приоритета

Объявление группы приоритета вводит в вашу программу новую группу для приоритета инфиксных операторов. Приоритет оператора указывает, насколько тесно оператор привязывается к своим операндам при отсутствии группирующих скобок.

Объявление группы приоритета имеет следующую форму:

```swift
precedencegroup precedence group name {
    higherThan: lower group names
    lowerThan: higher group names
    associativity: associativity
    assignment: assignment
}
```

Списки имен нижних групп (lower group names) и имен высших групп (higher group names) определяют отношение новой группы приоритета к существующим группам приоритета. Атрибут группы приоритета `lowerThan` может использоваться только для ссылки на группы приоритета, объявленные вне текущего модуля. Когда два оператора конкурируют друг с другом за свои операнды, например, в выражении `2 + 3 * 5`, оператор с более высоким относительным приоритетом более тесно связывается со своими операндами.

> Группы приоритета, связанные друг с другом с помощью имен более низких групп (lower group names) и имен более высоких групп (higher group names), должны вписываться в единую реляционную иерархию, но они не должны формировать линейную иерархию. Это означает, что можно иметь группы приоритета с неопределенным относительным приоритетом. Операторы из этих групп приоритета нельзя использовать рядом друг с другом без группирующих скобок.

Swift определяет многочисленные группы приоритета, соответствующие операторам, предоставляемым стандартной библиотекой. Группы были рассмотрены выше.

Ассоциативность (`associativity`) оператора указывает, как последовательность операторов с одинаковым уровнем приоритета группируется вместе при отсутствии группирующих скобок. Необходимо указывать ассоциативность оператора, написав одно из контекстно-зависимых ключевых слов `left`, `right` или `none` — если не указать ассоциативность, по умолчанию используется значение `none`.

Левоассоциативные операторы группируются слева направо. Например, оператор вычитания (`-`) является левоассоциативным, поэтому выражение `4 - 5 - 6` группируется как `(4 - 5) - 6` и определяется как `-7`. Операторы, которые являются правоассоциативными, группируются справа налево, а операторы, для которых указана ассоциативность none, вообще не связаны. Неассоциативные операторы одного уровня приоритета не могут располагаться рядом друг с другом. Например, оператор `<` имеет ассоциативность `none`, что означает, что `1 < 2 < 3` является недопустимым выражением.

Присвоение (`assignment`) группы приоритета указывает приоритет оператора при использовании в операции, которая включает опциональную цепочку (optional chaining). Если установлено значение `true`, оператор в соответствующей группе приоритета использует те же правила группировки во время опционального связывания, что и операторы присваивания из стандартной библиотеки. В противном случае, если установлено значение `false` или опущено, операторы в группе приоритета следуют тем же правилам опциональной цепочки, что и операторы, которые не выполняют присваивание.

### Вернёмся к объявлению пользовательских операторов

Рассмотрим оператор возведения в степень `**`, встречающийся во многих языках программирования, но отсутствующий в Swift. Он возводит левое число в степень правого числа. (Символ `^`, обычно используемый для надстрочных индексов, уже используется побитовым оператором XOR).

Возведение в степень имеет более высокий приоритет оператора, чем умножение, и, поскольку в Swift нет встроенной группы приоритета, которую мы могли бы использовать, нам сначала нужно объявить ее самостоятельно:

```swift
precedencegroup ExponentiationPrecedence {
    associativity: right
    higherThan: MultiplicationPrecedence
}
```

Теперь можно объявить сам оператор:

```swift
infix operator ** : ExponentiationPrecedence
```

Наконец, реализуем функцию верхнего уровня, используя наш новый оператор:

```swift
func ** (lhs: Double, rhs: Double) -> Double {
    return pow(lhs, rhs)
}

2 ** 3 // 8
```

> Нужно импортировать модуль Foundation для доступа к стандартной математической функции `pow(_:_:)`.

Когда создаете собственный оператор, рассмотрите также возможность предоставления изменяемого варианта:

```swift
infix operator **= : AssignmentPrecedence
func **= (lhs: inout Double, rhs: Double) {
    lhs = pow(lhs, rhs)
}

var n: Double = 10
n **= 1 + 2 // n = 1000
```

## Использование математических символов

Пользовательский оператор может использовать комбинации символов /, =, -, +, !, *, %, <, >, &, |, ^ или ~, а также любые символы, найденные в блоке математических операторов Unicode, среди прочих.

Это позволяет извлекать квадратный корень из числа с помощью одного префиксного оператора `√`:

```swift
prefix operator √
prefix func √ (_ value: Double) -> Double {
    return sqrt(value)
}

√4 // 2
```

Или рассмотрим оператор `±`, который можно использовать как инфиксный или префиксный оператор для возврата кортежа с суммой и разностью:

```swift
infix operator ± : AdditionPrecedence
func ± <T: Numeric>(lhs: T, rhs: T) -> (T, T) {
    return (lhs + rhs, lhs - rhs)
}

prefix operator ±
prefix func ± <T: Numeric>(_ value: T) -> (T, T) {
    return 0 ± value
}

2 ± 3 // (5, -1)

±4 // (4, -4)
```

Как было сказано выше, при объявлении операторной функции для префиксных операторов необходимо указывать ключевое слово `prefix` перед объявлением функции; для постфиксных операторов необходимо указывать ключевое слово `postfix` перед объявлением функции; для инфиксных операторов - ключевое слово перед объявлением функции не нужно указывать.

Пользовательские операторы трудно ввести и, следовательно, трудно использовать, поэтому соблюдайте осторожность с экзотическими символами. Код должен быть напечатан, а не скопирован. 

При переопределении или определении новых операторов в собственном коде обязательно следуйте этим рекомендациям:

- Не создавайте оператор, если его значение не очевидно и бесспорно. Ищите любые потенциальные конфликты, чтобы обеспечить семантическую согласованность.
- Обратите внимание на приоритет и ассоциативность пользовательских операторов и определяйте новые группы операторов только по мере необходимости.
- Если это имеет смысл, рассмотрите возможность назначения вариантов для вашего пользовательского оператора (например, `+=` для `+`).

---

## Создание пользовательских операторов в Swift

Пользовательские операторы обычно определяются для трех целей:

1. Определить совершенно новый оператор, потому что вы думаете, что значение символа может выразить то, что оператор будет делать лучше, чем функция с именем.
2. Чтобы определить оператор, который существует для базовых типов данных, таких как числа или строки, но не существует для определенных вами классов или структур
3. Вы хотите переопределить оператор, который уже существует для ваших классов и структур, но вам нужно, чтобы он вел себя по-другому.

Давайте рассмотрим все три цели на примерах.

## Создание нового оператора с новым символом

Допустим, вы хотите определить оператор с символом `△`, который вычисляет гипотенузу прямоугольного треугольника по двум его сторонам.

```
infix operator △
func △(lhs: Double, rhs: Double) -> Double {
    return sqrt(lhs*lhs + rhs*rhs)
}

var hypotenuse = 3△4

// Output
// 5
```

## Создание оператора для пользовательского класса или структуры

Как известно, оператор `+` используется для сложения двух чисел, но предположим, что необходимо добавить два экземпляра нашей структуры с именем `Velocity`, которая является двумерной сущностью:

```
struct Velocity {
    var xVelocity: Double
    var yVelocity: Double
}
```

Если бы мы запустили следующую команду, то получили бы ошибку компилятора (compiler error):

```
let velA = Velocity(xVelocity: 2, yVelocity: 4)
let velB = Velocity(xVelocity: 2, yVelocity: 4)
let velC = velA + velB // Binary operator + cannot be applied to two Velocity operands
```

В этом случае имеет смысл определить оператор `+`, который добавляет два экземпляра `Velocity`:

```
extension Velocity {
    static func +(lhs: Velocity, rhs: Velocity) -> Velocity {
            return Velocity(xVelocity: lhs.xVelocity + rhs.xVelocity,
                            yVelocity: lhs.yVelocity + rhs.yVelocity)
    }
}
```

Теперь предыдущий оператор будет выполняться правильно.

## Переопределение оператора Swift, который уже существует для класса/структуры

Переопределение оператора - это переопределение логики действия существующего оператора.

Если логика действия существующего оператора не подходит для решения поставленной задачи можно выполнить одно из двух - либо вы перегружаете существующий оператор, либо создаете новый.

Перегрузка работает так же, как перегрузка метода, в том смысле, что вы создаете новую версию оператора либо с новыми входными данными, либо с новыми выходными данными.

Допустим, у вас есть структура, которая используется для определения товара в супермаркете.

```
struct Item: Equatable {
    let id = UUID()
    let itemName: String
    let itemType: String
    let itemPrice: Double
}
```

Когда нам нужно сравнить два элемента, например, если два элемента имеют одинаковые `itemName`, `itemType` и `itemPrice`, нам нужно считать их равными независимо от их `id`.

Если вы запустите следующий фрагмент кода, вы увидите, что две переменные не равны:

```
let detergentA = Item(itemName: "Tide", itemType: "Detergent", itemPrice: 56.5)
let detergentB = Item(itemName: "Tide", itemType: "Detergent", itemPrice: 56.5)
let areDetergentsEqual = detergentA == detergentB // false
```

Причина этого в том, что экземпляры `detergentA` и `detergentB` имеют разные `id`. В этом случае нам нужно переопределить оператор (Operator overloading) `==` и пользовательскую логику, чтобы определить равенство.

```
extension Item {
    static func ==(lhs: Item, rhs: Item) -> Bool {
        return lhs.itemName == rhs.itemName &&
               lhs.itemPrice == rhs.itemPrice &&
               lhs.itemType == rhs.itemType
    }
}
```

## Определение пользовательского оператора в Swift

Пользовательский оператор определяется так же, как функция в Swift. Вы можете определить два типа операторов:

- Глобальный оператор
- Оператор, специфичный для класса/структуры

Определение выглядит следующим образом:

```
func <operator symbol>(parameters) { 
 // operator logic
}
```

Существуют различные типы параметров, которые вы можете определить в зависимости от того, является ли это инфиксным (infix) или префиксным (prefix)/постфиксным (postfix) оператором.

Если это инфиксный оператор, у вас может быть два параметра, а если это префиксный/постфиксный оператор, у вас может быть один параметр.

### Глобальный оператор

С глобальными операторами мы сначала определяем оператор с помощью ключевого слова нотации (`infix` , `prefix` или `postfix`) и ключевого слова `operator`, например:

```
<notation> operator <operator symbol>
```

Пример (инфиксный оператор ^^)

```
infix operator ^^
```

### Оператор для класса/структуры

Когда мы хотим определить оператор для класса или структуры, нам нужно определить операторную функцию как статическую функцию (static function). Параметр `notation` является необязательным, если оператор является инфиксным оператором (т. е. у вас есть два параметра в сигнатуре функции), в противном случае вам нужно указать `prefix` или `postfix`:

```
extension <class name> {
  static <notation> func ^(parameters) { // note that this needs to be static function
    // operator logic
  }
}
```

Учитывая, что уже рассмотрели определение базовых пользовательских операторов, таких как `+` и `==`, давайте рассмотрим несколько примеров того, как вы можете определить пользовательские составные операторы или операторы, изменяющие сами параметры.

Сделаем это, определив пользовательский составной арифметический оператор для структуры `Velocity` ранее:

```
extension Velocity {
    static func +=(lhs: inout Velocity, rhs: Velocity) { // note that the first parameter is an inout variable
        lhs.xVelocity = lhs.xVelocity + rhs.xVelocity
        lhs.yVelocity = lhs.yVelocity + rhs.yVelocity
    }
}
```

Теперь давайте выполним следующий код:

```
var velA = Velocity(xVelocity: 5, yVelocity: 5)
var velB = Velocity(xVelocity: 5, yVelocity: 5)
velA += velB
print(velA)

// Output
// Velocity(xVelocity: 10.0, yVelocity: 10.0)
```

### Мутирующие функции как альтернатива

Другим способом, которым мы могли бы решить описанную выше проблему, было бы использование изменяющей функции (Mutating functions) вместо перегрузки оператора. Мы могли бы добавить функцию, которая добавляет свойствам одного экземпляра значения свойств другой экземпляра, например:

```
extension Velocity {
    mutating func reduce(by velocity: Velocity) {
        xVelocity += velocity.xVelocity
        yVelocity += velocity.yVelocity
    }
}
velA.reduce(by: velB)
print(velA)

// Output
// Velocity(xVelocity: 10.0, yVelocity: 10.0)
```

Оба решения имеют свои достоинства, и вы можете возразить, что подход с мутирующей функцией является более явным.

Однако вы также не хотели бы, чтобы стандартный API вычитания для чисел был чем-то вроде `5.reduce(by: 3)`, поэтому, возможно, это тот случай, когда перегрузка оператора имеет смысл.

## Указание нотации пользовательского оператора в Swift

Чтобы определить нотацию пользовательского оператора, у вас есть три ключевых слова для соответствующей нотации:

- infix
- postfix
- prefix

При определении глобального оператора необходимо сначала определить нотацию оператора, а затем определить его функции. Обратите внимание, что это необязательный шаг, но он необходим, если вы хотите определить глобальные операторы или надеетесь присвоить им приоритет (о чем мы поговорим в следующем разделе).

Давайте посмотрим на оператор гипотенузы, который определяется как глобальный оператор. Вы можете видеть, что мы сначала определяем оператор с обозначением и символом, затем реализуем его логику:

```
infix operator △ // define the operator with its notation and symbol
func △(lhs: Double, rhs: Double) -> Double { // implement the operator logic
    return sqrt(lhs*lhs + rhs*rhs)
}

var hypotenuse = 3△4 // 5
```

При определении оператора для собственного класса/структуры вы можете напрямую использовать ключевое слово нотации с определением метода. Например, давайте также определим оператор для `Velocity`, который меняет знак для свойства `xVelocity` и `yVelocity`. Этот оператор будет определен как префиксный оператор:

```
extension Velocity {
    // defining a prefix negation operator
    static prefix func -(operand: Velocity) -> Velocity {
        return Velocity(xVelocity: -val.xVelocity, yVelocity: -val.yVelocity)
    }
}

let vel = Velocity(xVelocity: 4, yVelocity: 4)
print(-vel)

// Output
// xVelocity: -4, yVelocity: -4
```

## Установка приоритета пользовательских операторов Swift

Вы также можете определить приоритет вашего оператора, используя ключевые слова приоритета, как указано в таблице приоритетов. Обычно это делается на этапе определения:

```
infix operator ~: AdditionPrecedence // now this operator's priority is the same at the operators mentioned in the AdditionPrecedence
func ~(lhs: Int, rhs: Int) -> Double {
  return sqrt(Double(lhs*lhs-rhs*rhs))
}
```

Теперь приоритет этого оператора одинаков с операторами, указаных в группе AdditionPrecedence.

Таким образом, компилятор знает, какой оператор нужно выполнить первым. Если приоритет не указан, по умолчанию используется значение DefaultPrecedence, которое выше, чем TernaryPrecedence.

Более детально про приоритет операторов и ассоциативность операторов можно узнать в отдельной статье. См. ссылки внизу.

## Расчеты макета (Layout calculations)

Давайте рассмотрим другой сценарий, в котором использование перегрузки операторов может быть весьма полезным. Несмотря на то, что у нас есть Auto Layout и его мощный API привязки макета, иногда мы оказываемся в ситуациях, когда нам нужно выполнить расчеты макета вручную.

В подобных ситуациях очень часто приходится выполнять математические операции с двумерными значениями, такими как `CGPoint`, `CGSize` и `CGVector`. Например, нам может понадобиться вычислить исходную точку метки, используя размер изображения и дополнительное поле, например:

```
label.frame.origin = CGPoint(
    x: imageView.bounds.width + 10,
    y: imageView.bounds.height + 20
)
```

Вместо того, чтобы постоянно расширять точки и размеры для использования лежащих в их основе компонентов, было бы неплохо, если бы мы могли просто складывать их (точно так же, как мы делали это со структурой `Velocity`)?

Чтобы сделать это, мы могли бы начать с перегрузки оператора `+`, чтобы он принимал два экземпляра `CGSize` в качестве входных данных и выводил значение `CGPoint`:

```
extension CGSize {
    static func +(lhs: CGSize, rhs: CGSize) -> CGPoint {
        return CGPoint(
            x: lhs.width + rhs.width,
            y: lhs.height + rhs.height
        )
    }
}
```

Теперь можно написать расчет макета следующим образом:

```
label.frame.origin = imageView.bounds.size + CGSize(width: 10, height: 20)
```

Это довольно круто, но немного странно создавать `CGSize` для отступов. Один из способов сделать это немного лучше — определить другую перегрузку `+`, которая принимает размер и кортеж, содержащий два значения `CGFloat`, например:

```
extension CGSize {
    static func +(lhs: CGSize, rhs: (x: CGFloat, y: CGFloat)) -> CGPoint {
        return CGPoint(
            x: lhs.width + rhs.x,
            y: lhs.height + rhs.y
        )
    }
}
```

Это позволяет написать расчет макета одним из этих двух способов:

```
// Using a tuple with labels:
label.frame.origin = imageView.bounds.size + (x: 10, y: 20)

// Or without:
label.frame.origin = imageView.bounds.size + (10, 20)
```

## Пользовательский оператор для обработки ошибок

До сих пор мы просто добавляли перегрузки к существующим операторам. Но если мы хотим начать использовать операторы для функций, которые нельзя сопоставить с существующими, нам нужно определить свои собственные.

Давайте посмотрим на другой пример. Механизм обработки ошибок Swift `do, try, catch` очень удобен при работе с ошибочными синхронными операциями. Это позволяет легко и безопасно выйти из функции, как только возникает ошибка, например, при загрузке моделей, сохраненных на диске:

```
class NoteManager {
    func loadNote(fromFileNamed fileName: String) throws -> Note {
        let file = try fileLoader.loadFile(named: fileName)
        let data = try file.read()
        let note = try Note(data: data)
        return note
    }
}
```

Единственным серьезным недостатком выполнения чего-то подобного вышеизложенному является то, что мы напрямую передаем любые основные ошибки вызывающей стороне нашей функции.

В идеале нам нужен конечный набор ошибок, которые может выдать данный API, чтобы мы могли легко обрабатывать каждый случай отдельно. Допустим, мы также хотим зафиксировать все основные ошибки, что дает нам лучшее из обоих миров. Определяем перечисление ошибок с явными случаями, каждый из которых использует связанные значения для основной ошибки, например:

```
extension NoteManager {
    enum LoadingError: Error {
        case invalidFile(Error)
        case invalidData(Error)
        case decodingFailed(Error)
    }
}
```

Однако захват основных ошибок и преобразование их в наш собственный тип сложнее. Используя только стандартный механизм обработки ошибок, нам пришлось бы написать что-то вроде этого:

```
class NoteManager {
    func loadNote(fromFileNamed fileName: String) throws -> Note {
        do {
            let file = try fileLoader.loadFile(named: fileName)

            do {
                let data = try file.read()

                do {
                    return try Note(data: data)
                } catch {
                    throw LoadingError.decodingFailed(error)
                }
            } catch {
                throw LoadingError.invalidData(error)
            }
        } catch {
            throw LoadingError.invalidFile(error)
        }
    }
}
```

Я не думаю, что кто-то захочет читать код, подобный приведенному выше. Одним из вариантов является введение функции `perform`, которую можно использовать для преобразования одной ошибки в другую:

```
class NoteManager {
    func loadNote(fromFileNamed fileName: String) throws -> Note {
        let file = try perform(fileLoader.loadFile(named: fileName),
                               orThrow: LoadingError.invalidFile)

        let data = try perform(file.read(),
                               orThrow: LoadingError.invalidData)

        let note = try perform(Note(data: data),
                               orThrow: LoadingError.decodingFailed)

        return note
    }
}
```

Лучше, но у нас по-прежнему много кода преобразования ошибок, загромождающего нашу реальную логику. Давайте посмотрим, поможет ли введение нового оператора немного очистить этот код.

### Добавление нового оператора

начнем с определения нашего нового оператора. В этом случае выберем `~>` в качестве символа (по той причине, что это альтернативный тип возвращаемого значения, поэтому ищем что-то похожее на `->`).

```
infix operator ~>
```

Что делает операторов такими мощными, так это то, что они могут автоматически захватывать контекст с обеих сторон. Объедините это с функцией Swift `@autoclosure`, и сможем создать что-то довольно крутое.

```
func ~><T>(expression: @autoclosure () throws -> T,
           errorTransform: (Error) -> Error) throws -> T {
    do {
        return try expression()
    } catch {
        throw errorTransform(error)
    }
}
```

Поскольку `enum cases` со связанными значениями также являются статическими функциями в Swift, можно просто добавить `~>`. Между пробрасывающим выражением и случаем ошибки, в который хотим преобразовать любую основную ошибку, например:

```
class NoteManager {
    func loadNote(fromFileNamed fileName: String) throws -> Note {
        let file = try fileLoader.loadFile(named: fileName) ~> LoadingError.invalidFile
        let data = try file.read() ~> LoadingError.invalidData
        let note = try Note(data: data) ~> LoadingError.decodingFailed
        return note
    }
}
```

Используя оператор, мы убрали из нашей логики много «мусора» и синтаксиса, придав нашему коду больше понимания. Однако недостатком является то, что мы ввели новый вид синтаксиса для обработки ошибок, который, вероятно, будет совершенно незнаком любым новым разработчикам, которые могут присоединиться к нашему проекту в будущем.

## Заключение

Пользовательские операторы и перегрузка операторов — очень мощная функция, которая позволяет нам создавать действительно интересные решения. Это может позволить нам уменьшить многословие без необходимости вложенных вызовов функций, что может дать нам более чистый код. Однако это также может быть скользкий путь, который может привести нас к загадочному, трудночитаемому коду, который становится очень пугающим и запутанным для других разработчиков.

Это подводит нас к выводу о том, как вы можете создать свои собственные операторы. Хотя они довольно просты в использовании, важно понимать их, поскольку они являются одной из самых фундаментальных конструкций любого языка программирования.

Вы должны быть знакомы с основными операторами, так как вы будете часто использовать их в своем коде, и, когда дело доходит до пользовательских операторов, определяйте их только в том случае, если исходное значение символа имеет для вас смысл.

---

## Еще полезные ссылки

- [Переменные и константы](https://robot.obo.dev/read/posts/variable/)
- [Операторы](https://robot.obo.dev/read/posts/operator/)
- [Приоритет операторов и ассоциативность](https://robot.obo.dev/read/posts/operator-precedence/)
- [Побитовые операторы](https://robot.obo.dev/read/posts/operator-bitwise/)
- [Типы данных](https://robot.obo.dev/read/posts/data-type/)
- [Литералы](https://robot.obo.dev/read/posts/literal/)
- [Опционалы](https://robot.obo.dev/read/posts/optional-data-type/)
- [Функции](https://robot.obo.dev/read/posts/function/)

Также информацию по операторам можно получить на странице официальной документации.

Ссылки на официальную документацию:

- [Apple Developer Documentation - Operator Declarations](https://developer.apple.com/documentation/swift/operator-declarations)
- [Swift.org - Operator Declaration](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380)
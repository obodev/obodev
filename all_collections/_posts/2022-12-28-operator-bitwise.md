---
layout: post
title: Побитовые операторы (Bitwise Operators)
date: 2022-12-28
categories: ["Swift", "SPL"]
---

Побитовые операторы позволяют манипулировать отдельными битами необработанных данных внутри структуры данных. Они часто используются в низкоуровневом программировании, например программирование графики или создание драйвера для устройства. Побитовые операторы также могут быть полезны, когда вы работаете с необработанными данными из внешних ресурсов, например, кодирование или декодирование данных для связи через собственный протокол.

Swift поддерживает все побитовые операторы, которые были основаны в языке C о которых мы поговорим далее.

Побитовые операторы выполняют операции над целочисленными данными на уровне отдельных битов. Эти операции включают проверку, настройку или сдвиг фактических битов. Например,

```swift
a & b
a | b
```

В примере `&` и `|` являются побитовыми операторами. Вот список различных побитовых операторов, включенных в Swift.

Оператор  | Название                                     | Пример
:--------:|:---------------------------------------------|:-------:
`&`       | Побитовое И (Bitwise AND)                    | `a & b`
`\|`      | Побитовое ИЛИ (Bitwise OR)                   | `a \| b`
`^`       | Побитовое исключающее ИЛИ (Bitwise XOR)      | `a ^ b`
`~`       | Побитовое НЕ (Bitwise NOT)                   | `~a`
`<<`      | Побитовый сдвиг влево (Bitwise Shift Left)   | `a << b`
`>>`      | Побитовый сдвиг вправо (Bitwise Shift Right) | `a >> b`

## Побитовый оператор И

**Побитовый оператор И** (`&`) возвращает `1` тогда и только тогда, когда оба операнда равны `1`. В противном случае он возвращает `0`. Побитовая операция И над `a` и `b` может быть представлена ​​в таблице ниже:

a   | b  | a & b
:--:|:--:|:-----:
0   | 0  | 0
0   | 1  | 0
1   | 0  | 0
1   | 1  | 1

Примечание. Приведенная выше таблица известна как «Таблица истинности» (the "Truth Table") для побитового оператора И.

Давайте посмотрим на операцию побитового И двух целых чисел `12` и `25`:

```swift
12 = 00001100 (In Binary)
25 = 00011001 (In Binary)

// Bitwise AND Operation of 12 and 25

     00001100
&    00011001
_____________
     00001000  = 8 (In Decimal)
```

Пример: побитовый оператор И

```swift
var a = 12
var  b = 25

var result = a & b 
print (result)

// Output
// 8
```

В приведенном выше примере объявили две переменные `a` и `b`. Здесь обратите внимание на строку,

```swift
var result = a & b 
```

Здесь выполняем побитовую операцию И между `a` и `b`.

В примере ниже, значения `firstSixBits` и `lastSixBits` имеют четыре бита по середине равными `1`. Побитовый оператор AND комбинирует их для создания числа `00111100`, которое равно беззнаковому целому числу `60`:

```swift
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // равен 00111100
```

## Побитовый оператор ИЛИ

**Побитовый оператор ИЛИ** (`|`) возвращает `1`, если хотя бы один из операндов равен `1`. В противном случае он возвращает `0`. Побитовая операция ИЛИ над `a` и `b` может быть представлена ​​в таблице ниже:

a   | b  | a \| b
:--:|:--:|:-----:
0   | 0  | 0
0   | 1  | 1
1   | 1  | 1
1   | 0  | 1

Давайте посмотрим на операцию побитового ИЛИ двух целых чисел `12` и `25`:

```swift
12 = 00001100 (In Binary)
25 = 00011001 (In Binary)

// Bitwise OR Operation of 12 and 25

    00001100
|   00011001
____________
    00011101  = 29 (In decimal)
```

Пример: Побитовый оператор ИЛИ

```swift
var a = 12
var  b = 25

var result = a | b
print(result)

// Output
// 29
```

В приведенном выше примере объявили две переменные `a` и `b`. Здесь обратите внимание на строку,

```swift
var result = a | b 
```

Здесь выполняем побитовую операцию ИЛИ между `a` и `b`.

В примере ниже значения `someBits` и `moreBits` имеют разные биты со значениями `1`. Побитовый оператор OR комбинирует их для создания числа `11111110`, что равно беззнаковому целому числу `254`:

```swift
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // равен 11111110
```

## Побитовый оператор исключающее ИЛИ

**Побитовый оператор исключающее ИЛИ** (`^`) возвращает `1` тогда и только тогда, когда один из операндов равен `1`. Однако, если оба операнда равны `0` или оба равны `1`, результат равен `0`. Побитовая операция исключающее ИЛИ над `a` и `b` может быть представлена ​​в таблице ниже:

a   | b  | a ^ b
:--:|:--:|:-----:
0   | 0  | 0
0   | 1  | 1
1   | 0  | 1
1   | 1  | 0

Давайте посмотрим на операцию побитового исключающего ИЛИ двух целых чисел `12` и `25`:

```swift
12 = 00001100 (In Binary)
25 = 00011001 (In Binary)

// Bitwise XOR Operation of 12 and 25

    00001100
^   00011001
____________
    00010101  = 21 (In decimal)
```

Пример: Побитовый оператор исключающее ИЛИ

```swift
var a = 12
var  b = 25

var result = a ^ b
print(result)

// Output
// 21
```

В приведенном выше примере объявили две переменные `a` и `b`. Здесь обратите внимание на строку,

```swift
var result = a ^ b 
```

Здесь выполняем побитовую операцию исключающее ИЛИ между `a` и `b`.

В примере ниже, значения `firstBits` и `otherBits` каждый имеет один бит в том месте, где у другого `0`. Побитовый оператор XOR устанавливает оба этих бита в качестве выходного значения. Все остальные биты повторяются, поэтому оператор возвращает `0`:

```swift
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // равен 00010001
```

## Побитовый оператор НЕ

Побитовый оператор НЕ (`~`) инвертирует бит (`0` становится `1`, `1` становится `0`).

![](https://obodev.github.io/assets/images/operator-bitwise-not.png)

Побитовая операция НЕ над a может быть представлена ​​в таблице ниже:

a   | ~a
:--:|:--:
0   | 1
1   | 0

```swift
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits // равен 11110000
print(invertedBits)

// Output
// 240
```

Целые числа типа UInt8 имеют восемь бит и могут хранить значения от `0` до `255`. В этом примере инициализируем число типа UInt8, которое имеет бинарное значение `00001111`, которое имеет первые четыре бита равные `0`, а вторая четверка битов равна `1`. Это эквивалент числа `15`.

Далее используем побитовый оператор NOT для создания новой константы `invertedBits`, которая равна `initialBits`, но только с перевернутыми битами. То есть теперь все единицы стали нулями, а нули единицами. Значение числа `invertedBits` равно `11110000`, что является эквивалентом `240`.

Важно отметить, что побитовое НЕ любого целого числа `N` равно `-(N + 1)`.

Например, рассмотрим целое число `35`. Согласно правилу, побитовое НЕ числа `35` должно быть `-(35 + 1) = -36`.

Давайте посмотрим на операцию побитового НЕ числа `35`:

```swift
35 = 00100011 (In Binary)

// Using bitwise NOT operator
~  00100011 
   ________
   11011100
```

В приведенном выше примере побитовое НЕ `00100011` равно `11011100`. Здесь, если преобразуем результат в десятичный вид, получим `220`.

Однако важно отметить, что нельзя напрямую преобразовать результат в десятичный вид и получить желаемый результат. Это связано с тем, что двоичный результат `11011100` также эквивалентен `-36`.

Чтобы понять это, сначала нужно вычислить двоичный вывод `-36`. Для этого используется *Дополнительный код* (англ. "two’s complement").

Дополнительный код для отрицательного числа можно получить инвертированием его двоичного модуля и прибавлением к инверсии единицы, либо вычитанием числа из нуля.

```swift
36 = 00100100 (In Binary)

1's Complement = 11011011 (Inversion)

2's Complement :   
   11011011
+         1
   ________
   11011100   
```

Это значение эквивалентно побитовому дополнению 35, которое вычислили выше.

Пример: побитовый оператор НЕ

```swift
var  b = 12
var result = ~b

print(result)

// Output
// -13 
```

В приведенном выше примере выполнили побитовую операцию НЕ к значению `12`.

```swift
The bitwise complement of 12 = - (12 + 1) = -13
i.e. ~12 = -13
```

Именно это и получили на выходе.

## Операторы побитового левого и правого сдвига

Оператор побитового левого сдвига (`<<`) и оператор побитового правого сдвига (`>>`) двигают все биты числа влево или вправо на определенное количество мест, в зависимости от правил, которые определены ниже.

Побитовые операторы левого и правого сдвига имеют эффект умножения или деления числа на 2. Сдвигая биты целого числа влево на одну позицию, мы получаем удвоенное первоначальное число, в то время как, двигая его вправо на одну позицию, мы получаем первоначальное число поделённое на 2.

### Поведение сдвига для беззнаковых целых чисел

Поведение побитового сдвига имеет следующие правила:

- Существующие биты сдвигаются вправо или влево на требуемое число позиций.
- Любые биты, которые вышли за границы числа, отбрасываются.
- На пустующие позиции сдвинутых битов вставляются нули.

Такой подход называется *логическим сдвигом*.

Можно использовать побитовый сдвиг для кодирования и декодирования значений внутри других типов данных:

```swift
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16 // redComponent равен 0xCC, или 204
let greenComponent = (pink & 0x00FF00) >> 8 // greenComponent равен 0x66, или 102
let blueComponent = pink & 0x0000FF // blueComponent равен 0x99, или 153
```

Этот пример использует UInt32, который называется `pink`, для хранения значения розового цвета из файла CSS. Значение розового цвета `#CC6699`, что записывается в виде шестнадцатеричном представлении Swift как `0xCC6699`. Этот цвет затем раскладывается на его красный(`CC`), зеленый (`66`) и голубой (`99`) компоненты при помощи побитового оператора AND (`&`) и побитового оператора правого сдвига (`>>`).

Красный компонент получен с помощью побитового оператора AND между числами `0xCC6699` и `0xFF0000`. Нули в `0xFF0000` фактически являются “маской” для третьего и четвертого бита в `0xCC6699`, тем самым заставляя игнорировать `6699`, и оставляя `0xCC0000` в качестве результата.

После этого число сдвигается на 16 позиций вправо (`>> 16`). Каждая пара символов в шестнадцатеричном числе использует `8` битов, так что сдвиг вправо на 16 позиций преобразует число `0xCC0000` в `0x0000CC`. Это то же самое, что и `0xCC`, которое имеет целое значение равное `204`.

Аналогично с зеленым компонентом, который получается путем использования побитового оператора AND между числами `0xCC6699` и `0x00FF00`, который в свою очередь дает нам выходное значение `0x006600`. Это выходное значение затем сдвигается на восемь позиций вправо, давая нам значение `0x66`, что имеет целое значение равное `102`.

Ну а теперь последний синий компонент, который получается при использовании побитового оператора AND между числами `0xCC6699` и `0x0000FF`, что в свою очередь дает нам выходное значение равное `0x000099`. Таким образом, нам не нужно сдвигать это вправо, так как `0x000099` уже равно `0x99`, что имеет целое значение равное `153`.

### Поведение побитового сдвига для знаковых целых чисел

Поведение побитового сдвига для знаковых целых чисел более сложное, чем для беззнаковых, из-за того, как они представлены в бинарном виде. Знаковые целые числа используют первый бит (известный как знаковый бит) для индикации того, является ли число положительным или отрицательным. Значение знакового бита равное `0` свидетельствует о положительном числе, `1` - отрицательном.

Остальные биты (известные как биты значения) хранят фактическое значение. Положительные числа хранятся в точности так же как и беззнаковые целые числа, считая от `0`.

![](https://obodev.github.io/assets/images/operator-bitwise-bitshift-signed.png)

Знаковый бит равен `0` (число положительное), остальные семь битов означают число `4`, записанное в бинарной форме.

Отрицательные числа хранятся иначе. Они хранятся путем вычитания их абсолютного значения из `2` в степени `n`, где `n` - количество битов значения.

Вот как выглядит биты внутри Int8 для числа `-4`:

![](https://obodev.github.io/assets/images/operator-bitwise-bitshift-signed-minus.png)

В этот раз, знаковый бит равен 1 (число отрицательное), а остальные семь знаковых бита имеют бинарное значение числа `124` (что означает `128 - 4`): `1111100 = 124`.

### Побитовый сдвиг влево

Оператор сдвига влево сдвигает все биты влево на заданное число битов. Обозначается `<<`.

![](https://obodev.github.io/assets/images/operator-bitwise-left-shift.png)

Как видно из изображения выше,

- есть 4-значный номер. Когда выполняем над ним операцию сдвига влево на 1 бит, каждый бит сдвигается влево на 1 бит.
- в результате крайний левый бит отбрасывается, а самый правый бит остается пустым. Эту пустоту заменено на 0.

Пример: оператор сдвига влево

```swift
var a = 3
var result = a << 2

print(result)

// Output
// 12
```

В приведенном выше примере создали переменную `a` со значением `3`. Обратите внимание на выражение

```swift
var result = a << 2
```

Здесь выполнена операция сдвига влево на `2` бита в значении переменной `a`.

### Побитовый сдвиг вправо

Оператор сдвига вправо сдвигает все биты вправо на определенное количество заданных битов. Обозначается `>>`.

![](https://obodev.github.io/assets/images/operator-bitwise-right-shift.png)

Как видно из изображения выше,

- есть 4-значный номер. Когда выполняем над ним 1-битную операцию сдвига вправо, каждый бит сдвигается вправо на 1 бит.
- в результате самый правый бит отбрасывается, а самый левый бит остается пустым. Эта пустота заменяется на 0 для беззнаковых чисел.
- для чисел со знаком знаковый бит (`0` для положительного числа, `1` для отрицательного числа) используется для заполнения освободившихся битовых позиций.

> Примечание. Целое число со знаком представляет как положительные, так и отрицательные целые числа, тогда как целое число без знака представляет только положительные целые числа.

Пример: оператор сдвига вправо

```swift
var a = 4

var result = a >> 2
print(result)

// Output
// 1

a = -4

result = a >> 2
print(result)

// Output
// -1
```

В приведенном выше примере создали переменную `a` со значением `3`. Обратите внимание на выражение

```swift
var result = a << 2
```

В приведенном выше примере выполнены операции сдвига вправо на `2` бита для значений `4` и `-4`.

## Операторы переполнения

Числа могут переполняться как в положительную, так и в отрицательную сторону.

Ниже приведен пример того, что случится, когда беззнаковое значение позволяет переполнить себя, с использованием оператора (`&+`):

```swift
var willOverflow = UInt8.max
// willOverflow равняется 255, что является наибольшим числом, которое может держать UInt
willOverflow = willOverflow &+ 1
// willOverflow теперь равно 0
```

Переменная `willOverflow` инициализирована самым большим числом, которое может держать UInt8 (`255` или в бинарном виде `11111111`). Затем оно увеличивается на `1` при помощи оператора переполнения (`&+`). Это выталкивает бинарное представление размерности UInt8, вызывая тем самым переполнение границ, что отображено на диаграмме ниже. Значение, которое остается в пределах границ значения типа UInt8 после переполнения и добавления выглядит как `00000000`, или попросту `0` в десятичной форме:

![](https://obodev.github.io/assets/images/operator-bitwise-overflow-addition.png)

Числа так же могут быть слишком маленькими, чтобы соответствовать определенному типу. Ниже приведен пример с использованием оператора недополнения (&-)

```swift
var unsignedOverflow = UInt8.min
// unsignedOverflow равен 0, что является наименьшим возможным значением UInt8
unsignedOverflow = unsignedOverflow &- 1
// unsignedOverflow теперь равно 255
```

Самое маленькое значение, которое может держать UInt8 равно `0` (что отображается как `00000000` в восьмибитной бинарной форме). Если вы из `00000000` вычтите `1`, с использованием оператора недополнения, число переполнится в обратную сторону к `11111111`, или к `255` в десятичной форме:

![](https://obodev.github.io/assets/images/operator-bitwise-overflow-unsignedSubtraction.png)

Аналогичное недополнение случается и с знаковыми целыми числами. Все вычитание для знаковых целых чисел проводится как прямое бинарное вычитание с учетом знакового бита, в качестве части вычитаемых чисел.

```swift
var signedUnderflow = Int8.min
// signedUnderflow равняется -128, что является самым маленьким числом, которое может держать Int8
signedUnderflow = signedUnderflow &- 1
// signedUnderflow теперь равняется 127
```

Самым маленьким числом, которое может держать Int8, является `–128`, что записывается в бинарной форме как `10000000`. Вычитая `1` из этого бинарного числа с оператором недополнения, дает нам значение `01111111`, что переключает наш знаковый бит на противоположный и дает нам положительное `127`, что является самым большим числом, которое может держать Int8:

![](https://obodev.github.io/assets/images/operator-bitwise-overflow-signedSubtraction.png)

Конечный результат поведения переполнения и недополнения описан выше и одинаково работает как для знаковых, так и для беззнаковых целых чисел. Переполнение всегда переворачивает значение с самого большого на самое маленькое, недополнение всегда переворачивает самое маленькое число на самое большое.

---

## Еще полезные ссылки

- [Переменные и константы](https://robot.obo.dev/read/posts/variable/)
- [Операторы](https://robot.obo.dev/read/posts/operator/)
- [Приоритет операторов и ассоциативность](https://robot.obo.dev/read/posts/operator-precedence/)
- [Перегрузка операторов. Пользовательские операторы](https://robot.obo.dev/read/posts/operator-custom/)
- [Типы данных](https://robot.obo.dev/read/posts/data-type/)
- [Литералы](https://robot.obo.dev/read/posts/literal/)
- [Опционалы](https://robot.obo.dev/read/posts/optional-data-type/)
- [Функции](https://robot.obo.dev/read/posts/function/)

Также информацию по операторам можно получить на странице официальной документации.

Ссылки на официальную документацию:

- [Swift.org - Bitwise Operators](https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID29)
---
layout: post
title: Операторы
date: 2022-12-28
categories: ["Swift", "SPL"]
---

# Операторы

Операторы являются одной из основных конструкций любого языка программирования. Они представлены в виде символов и имеют различные связанные свойства, и их понимание имеет решающее значение для освоения любого языка программирования.

Когда вы берете одну или несколько частей данных и превращаете их в другую часть данных, это называется операцией.

**Операторы** — это специальные символы, наборы символов или фразы, которые используются для выполнения операции (проверка, изменение, комбинирование) над значениями. Используются в выражениях.

Значения могут быть представлены литералами, переменными и константами, результатом выполнения функций и методов, результатом выполнения других операторов и операций.

**Операнд** - значение, на который влияет оператор. Оператор выполняет действие над операндами.

Например,

```swift
print(5 + 6)

// Output
// 11
```

Здесь `+` — это оператор, который складывает два числа: `5` и `6` (операнды), и возвращает этот результат.

## Типы операторов

Существует три различных типа операторов, которые определяются количеством операндов, над которыми они работают. По типу операторы бывают: 

- **унарные операторы** (Unary operators) действуют на один операнд (работают с одним операндом). **Унарные префиксные операторы** находятся непосредственно перед своим операндом (например, `!b`), а **унарные постфиксные операторы** находятся сразу после своего операнда (например, `c!`).
- **бинарные операторы** (Binary operators) действуют на два операнда (работают с двумя операндами). Являются инфиксными, потому что они находятся между двумя операндами (например, `a + b`).
- **тернарные операторы** (Ternary operators) действуют на три операнда (работают с тремя операндами). Как и в языке C, язык Swift имеет только один тернарный оператор, который называется **тернарный условный оператор** (`a ? b : c`).

## Обозначение оператора

Обозначение (Нотация) оператора определяет позицию оператора при использовании с операндами. Здесь снова три типа:

- **префиксные** (prefix) - размещаются непосредственно перед операндом, на который он влияет;
- **инфиксные** (infix) - размещаются непосредственно между двумя операндами, на которые он влияет. Бинарные и тернарные операторы всегда инфиксные;
- **постфиксные** (postfix) - размещаются непосредственно после операнда, на который он влияет.

Унарные операторы записываются без пробелов по отношению к операндам.

Бинарные и тернарные операторы записываются с пробелами и без по отношению к операндам. Принято записывать с пробелами, так как это позволит избежать разные ошибки. например


```swift
var a = 5, b = 6
print(a + -b)

// Output
// -1
```

В этом примере в функции `print()` используется значение переменной `b` с обратным знаком. Если записать выражение `a + -b` без пробелов, то получится ошибка, так как запись `+-` будет восприниматься как необъявленный инфиксный оператор `+-`.

Также недопустима запись инфиксных операторов с одновременным использованием записи с пробелом и без. Так как, если выражение `a + b` записать как `a+ b`, то символ `+` будет восприниматься как унарный постфиксный оператор по отношению к операнду `a`.

**Важно!!!** Операции с бинарными операторами почти всегда требуют, чтоб операнды имели один и тот же тип данных. Это значит, что нельзя проводить арифметические операции, операции сравнения, логические операции с разными типами. Если возникает необходимость в этих действиях - следует привести их к одному типу. Логические операции вообще могут выполнятся только с логическими типами данных.

```swift
var a: Int = 2 + 0.3 // Error: Cannot convert value of type 'Double' to specified type 'Int'
var b: Int = Int(3 + 1.5)
```

В этом примере

- переменная `a` имеет тип `Int`, а выражение `2 + 0.3` будет иметь тип 'Double';
- переменная `b` имеет тип `Int`, а выражение `3 + 1.5` будет иметь тип 'Double', но это выражение приведено к типу `Int` с помощью конструкции `Int()`;

---

Вот список различных типов операторов Swift:

- Арифметические операторы
- Операторы присваивания
- Операторы сравнения
- Логические операторы
- Побитовые операторы
- Другие операторы

## 1. Арифметические операторы (Arithmetic Operators)

Арифметические операторы используются для выполнения математических операций, таких как сложение, вычитание, умножение и т.д. Например,:

```swift
var sub = 10 - 5

// Output
// 5
```

Здесь `-` арифметический оператор, который вычитает два значения или переменные.

Оператор  | Символ | Описание                                           | Пример
:---------|:------:|:---------------------------------------------------|:----------:
Сложения  | `+`    | Прибавляет к первому операнду второй               | `5 + 2 = 7`
Вычитания | `-`    | Вычитает из первого операнда второй                | `4 - 2 = 2`
Умножения | `*`    | Умножает первый операнд на второй                  | `2 * 3 = 6`
Деления   | `/`    | Делит первый операнд на второй                     | `4 / 2 = 2`
Модуляции | `%`    | Делит первый операнд на второй и возвращает остаток| `5 % 2 = 1`

Пример:

```swift
var a = 7
var b = 2

// addition
print (a + b)  

// subtraction
print (a - b) 

// multiplication
print (a * b)  

// Output
// 9
// 5
// 14
```

В приведенном выше примере использовали

- `+` для сложения `a` и `b` 
- `-` для вычитания `b` из `a`
- `*` для умножения `a` на `b`

### Оператор сложения (`+`)

Оператор сложения (`+`) выполняет сложение между двумя числами. Например,

```swift
let x = 10
let y = 20
let sum = x + y
print(sum)

// Output
// 30
```

Также можно указать несколько операторов сложения в одну строку:

```swift
let sum = 1 + 2 + 3 + 4
print(sum)

// Output
// 10
```

Оператор сложения также поддерживает конкатенацию строк

```swift
// String concatenation
print ("hello, " + "world")  

// Output
// "hello, world"
```

Более детально про конкатенацию можно узнать в отдельной статье ("Литералы"). См. ссылки внизу.

### Оператор вычитания (`-`)

Оператор вычитания (`-`) выполняет вычитание правого операнда из левого. Например,

```swift
let x = 10
let y = 20
let diff = x - y
print(diff)
Output:

-10
```

Также можно указать несколько операторов вычитания в одну строку:

```swift
let diff = 1 - 2 - 3 - 4
print(diff)

// Output
// -8
```

### Оператор умножения (`*`)

Оператор умножения (`*`) выполняет умножение между двумя числами. Например,

```swift
let x = 10
let y = 20
let prod = x * y
print(prod)

// Output
// 200
```

Также можно указать несколько операторов умножения в одну строку:

```swift
let prod = 5 * 4 * 3
print(prod)

// Output
// 60
```

### Оператор деления (`/`)

Оператор деления (`/`) выполняет деление между двумя числами - делит значение левого операнда на значение правого. Однако, если два числа являются целыми числами, то оператор деления вернёт только частное. Например,

```swift
// returns quotient only
7 / 2 = 3 // 3 - частное, 1 - остаток
```

Если использовать оператор деления `/` с числами с плавающей точкой, то он вернёт фактический результат. Например,

```swift
// perform division
7.0 / 3.0 = 3.5
```

Также можно указать несколько операторов деления в одну строку:

```swift
let frac = 5.0 / 10.0 / 2.0
print(frac)

// Output
// 0.25
```

Оператор деления (`/`) возвращает число, которое показывает сколько раз содержится правого операнда в левом (делителя в делимом).

```swift
print(20 / 5)

// Output
// 4
```

- в `20` содержится четыре целых `5`

```swift
print(20 / 6)

// Output
// 3
```

- в `20` содержится три целых `6`

Чтоб получить десятичное значение во втором примере, следует использовать числа с плавающей точкой:

```swift
print(20.0 / 6.0)

// Output
// 3.33333333333333 
```

### Оператор остатка от деления (Remainder Operator) (`%`)

Оператор остатка от деления (`%`) вычисляет и возвращает остаток при делении левого операнда на правый. 

Операция остатка, также называемая **операцией модуляции**. При делении знаменатель входит в числитель целое число раз, плюс остаток. То есть число можно представить следующей формулой:

`a = k * b + n`

- `k` - указывает сколько целых раз `b` входит в `a`;
- `n` - остаток от деления.

Этот остаток (`n`) и есть то, что дает операция остатка. 

Таким образом:

- `a / b = k`
- `a % b = n`

Например, `10` по модулю `3` равно `1`, потому что `3` трижды входит в `10` с остатком `1`.

`10 = 3 * 3 + 1`

Например,

```swift
print(9 % 4)

// Output
// 1
```

Пример

```swift
print(42 % 2)
print(31 % 5)
print(-31 % 5)
print(31 % -5)
print(-31 % -5)
print(-1 % 101)
print(-1 % -101)

// Output
// 0
// 1
// -1
// 1
// -1
// -1
// -1
```

Операция         | Объяснение
:---------------:|:------------:
`42 % 2 = 0`     | `42 = 21 * 2 + 0`
`31 % 5 = 1`     | `31 = 6 * 5 + 1`
`-31 % 5 = -1`   | `-31 = -6 * 5 + (-1)`
`31 % -5 = 1`    | `31 = 6 * (-5) + 1`
`-31 % -5 = -1`  | `-31 = 6 * (-5) + (-1)`
`-1 % 101 = -1`  | `-1 = 0 * 101 + (-1)`
`-1 % -101 = -1` | `-1 = 0 * (-101) + (-1)`

Обратите внимание на знаки. Знак перед остатком от деления **зависит от знака левого операнда**. Операция вычисления остатка от деления - **не является операцией деления**. Поэтому смены знака, как в операции деления, когда операнды (один или оба) имеют отрицательные значения - не будет.

Оператор `%` можно использовать только с целыми числами.

Если попробовать применить оператор `%` к числам с плавающей точкой, то будет ошибка

```swift
print(28.0 % 10.0) // Error: '%' is unavailable: For floating point numbers use truncatingRemainder instead
```

Компилятор подскажет, что необходимо использовать функцию `truncatingRemainder()` для чисел с плавающей точкой. Функция `truncatingRemainder()` выполнит деление, затем усекает результат, отсекая лишние десятичные знаки, и возвращает остаток. Результат идентичен `%`, когда нет десятичных знаков.

```swift
print((28.0).truncatingRemainder(dividingBy: 10.0))

// Output
// 8.0
```

### Переполнение типа

В отличие от языков C и Objective-C арифметические операторы Swift по умолчанию не допускают переполнения типа. Контроль переполнения типа включается в Swift специальными операторами.

Более детально про операторы переполнения можно узнать в отдельной статье ("Побитовые операторы"). См. ссылки внизу.

### Порядок арифметических операций

Можно использовать более одного оператора при вычислении значения. Вот пример того, как это сделать в Swift:

```swift
(8000 / (5 * 10)) - 32
```

Обратите внимание на использование круглых скобок, которые в Swift служат двум целям: дать понять любому, кто читает код — включая вас самих — что вы имели в виду, и разграничить выражение. Например, рассмотрим следующее:

> `350 / 5 + 2`

Равно ли оно `72` (350 разделить на 5, плюс 2) или `50` (350 разделить на 7)?

Правильный ответ - `72`.

Swift использует правила математики и добивается этого с помощью так называемого приоритета операторов. Оператор деления (`/`) имеет более высокий приоритет, чем оператор сложения (`+`), поэтому в данном примере код сначала выполняет операцию деления.

Если бы было необходимо, чтобы Swift сначала выполнил сложение — то есть вернул `50`, то можно использовать круглые скобки следующим образом:

> `350 / (5 + 2)`

Правила приоритета соответствуют тем, которые вы могли изучать в школе на уроках математики. Умножение и деление имеют одинаковый приоритет, более высокий, чем сложение и вычитание, которые также имеют одинаковый приоритет.

Более детально про порядок операций будет рассмотрено ниже.

### Унарный оператор минуса (Unary Minus Operator) (`-`)

Знак числового значения можно изменить с помощью префикса `-`, известного как унарный оператор минуса:

```swift
let one = 1
let minusOne = -one
let plusOne = -minusOne

print(one)
print(minusOne)
print(plusOne)

// Output
// 1
// -1 // minusOne равно -1, или "минус one"
// 1 // plusOne равно 1, или "минус minusOne"
```

Унарный минус `-` добавляется непосредственно перед значением, над которым он работает, без пробелов.

### Унарный оператор плюса (Unary Plus Operator) (`+`)

Унарный оператор плюс `+` просто возвращает значение, над которым он работает, без каких-либо изменений:

```swift
let minusOne = -1
let alsoMinusOne = +minusOne

print(minusOne)
print(plusOne)

// Output
// -1 // minusOne равно -1
// -1 // alsoMinusOne также равно -1, или "плюс minusOne"
```

Хотя унарный оператор плюс на самом деле ничего не делает, его можно использовать для обеспечения симметрии в своем коде для положительных чисел, в случае когда также используется унарный оператор минус для отрицательных чисел.

## 2. Операторы присваивания (Assignment Operators) и Составные операторы присваивания (Compound Assignment Operators)

Операторы присваивания используются для присваивания значений переменным, константам. Они позволяют проинициализировать или обновить значение переменным. Например,

```swift
// assign 5 to x 
var x = 5
```

Здесь `=` — это оператор присваивания, который присваивает переменной `х` значение `5` (инициализирует переменную `х` со значением `5`).

В отличие от оператора присваивания в языках программирования C и Objective-C, оператор присваивания в Swift сам по себе не возвращает значение.

Если требуется использовать результат сравнения двух операндов, следует использовать оператор сравнения `==`, а не присваивания `=`. Операторы сравнения указаны ниже.

Вот список различных операторов присваивания, доступных в Swift.

Оператор | Символ | Описание | Пример
:--------|:------:|:---------|:------
Присваивания </br> (Assignment) | `=` | Присваивает значение правого операнда левому | `a = 7`
Сложение с присваиванием </br> (Addition Assignment) | `+=` | Выполняет сложение и присваивает </br> значение левому операнду | `a += 1` </br> То же, что и </br> `a = a + 1`
Вычитание с присваиванием </br> (Subtraction Assignment) | `-=` | Выполняет вычитание и присваивает </br> значение левому операнду | `a -= 3` </br> То же, что и </br> `a = a - 3`
Умножение с присваиванием </br> (Multiplication Assignment) | `*=` | Выполняет умножение и присваивает </br> значение левому операнду | `a *= 4` </br> То же, что и </br> `a = a * 4`
Деление с присваиванием </br> (Division Assignment) | `/=` | Выполняет деление и присваивает </br> значение левому операнду | `a /= 3` </br> То же, что и </br> `a = a / 3`
Модуль с присваиванием </br> (Remainder Assignment) | `%=` | Выполняет модуляцию и присваивает </br> значение левому операнду | `a %= 10` </br> То же, что и </br> `a = a % 10`

Пример

```swift
// assign 10 to a
var a = 10

// assign 5 to b
var b = 5 

// assign the sum of a and b to a
a += b      // a = a + b

print(a)

// Output
// 15
```

### Оператор присваивания (`=`)

Оператор присваивания значения присваивает переменной или константе указанное значение. 

```swift
var name = "Bob" // переменной `name` присвоено значение `"Bob"`
var age = 30 // переменной `age` присвоено значение `30`
age = 32 // переменной `age` присвоено новое значение `32`
```

Присвоить можно конкретное значение, значение, которое является результатом операции, значение другой переменной, константы, функции

```swift
var a = 20 // переменной `a` присваивается указанное значение - `20`
var b = 20 + 5 // переменной `b` присваивается значение результата математической операции - `25`
var c = b // переменной `c` присваивается значение переменной `b` - `25`
func summ() -> Int { // функция возвращает результат сложения переменных `a` и `b` 
	return a + b
}
var d = summ() // переменной "d" присваивается результат выполнения функции "summ()" - 45
```

### Составные операторы присваивания (`+=`, `-=`, `*=`, `/=`, `%=`)

Часто встречающаяся операция, которая понадобится — это увеличение или уменьшение переменной на какое-то значение. То есть происходит две операции: вычисление нового значения и переприсвоение его переменной.

Пример (необходимо увеличить значение на `1`):

```swift
var count = 0
count = count + 1
```

В Swift можно объединить эти две операции:

```swift
var count = 0
count += 1
```

Код становиться меньше и более читаемым.

Оператор | Пример   | Объяснение
:-------:|:--------:|:----------:
`+=`     | `a += b` | `a = a + b`
`-=`     | `a -= b` | `a = a - b`
`*=`     | `a *= b` | `a = a * b`
`/=`     | `a /= b` | `a = a / b`
`%=`     | `a %= b` | `a = a % b`

```swift
var counter: Int = 0
counter += 15  // аналогично `counter = counter + 15`
// counter = 15
counter -= 5  // аналогично `counter = counter - 5` 
// counter = 10
counter *= 3  // аналогично `counter = counter * 3`
// counter = 30
counter /= 2  // аналогично `counter = counter / 2`
// counter = 15
counter %= 4  // аналогично `counter = counter % 4`
// counter = 3
```

Нельзя записать в одну строку несколько операторов присваивания

```
var count: Int = 0
var stride: Int = 15
count += stride += 1 // Error
```

## 3. Операторы сравнения (Comparison Operators)

Операторы сравнения сравнивают два операнда (их значения) и возвращают логический результат сравнения: правда (`true`) или ложь (`false`). Например,

```swift
var a = 5, b =2
print (a > b)

// Output
// true
```

Здесь оператор сравнения `>` используется для сравнения того, больше ли переменная `a`, чем `b` или нет.

Оператор                                   | Символ | Пример
:------------------------------------------|:------:|:------:
Равно, Эквивалентно (Is Equal To)          | `==`   | `3 == 5` вернёт `false`
Не равно не эквивалентно(Not Equal To)     | `!=`   | `3 != 5` вернёт `true`
Больше (Greater Than)                      | `>`    | `3 > 5` вернёт `false`
Меньше (Less Than)                         | `<`    | `3 < 5` вернёт `true`
Больше или равно (Greater Than or Equal To)| `>=`   | `3 >= 5` вернёт `false`
Меньше или равно (Less Than or Equal To)   | `<=`   | `3 <= 5` вернёт `true`
Идентично (Identical)                      | `===`  |
Не идентично (Not identical)               | `!==`  |
Соответствие шаблону (Pattern Matching)    | `~=`   |

### Оператор равно (`==`)

В Swift используется единственный знак равенства (`=`) в качестве оператора присваивания. Таким образом, его нельзя использовать в качестве оператора сравнения. Вместо этого, чтобы сравнить равенство, необходимо использовать оператор двойного равенства (`==`).

```swift
let n = 10
let m = 10
print(n == m)

// Output
// true
```

### Оператор не равно (`!=`)

Чтобы проверить, не равны ли два значения, используйте оператор неравенства (`!=`), поместив его между двумя сравниваемыми значениями.

Например, давайте сравним две переменные, чтобы увидеть, не равны ли они друг другу:

```swift
var x = 1.02
var y = 1.03
var notEqual: Bool = x != y
print(notEqual)

// Output
// true
```

### Оператор меньше (`<`)

В Swift можно проверить, меньше ли значение `a` значения `b`, с помощью оператора "меньше" (`a < b`).

Например, давайте проверим, моложе ли человек другого:

```swift
let ageAlice = 32
let ageBob = 21
print(ageAlice < ageBob)

// Output
// false
```

### Оператор меньше или равно (`<=`)

Можно проверить, меньше или равно значение `a` значению `b` с оператором "меньше или равно" (`a <= b`).

```swift
let balance = 100.00
let limit = 100.00
print(balance <= limit)

// Output
// true
```

### Оператор больше (`>`)

Можно проверить, больше ли значение `a`, чем значение `b`, с помощью оператора "больше" (`a > b`).

```swift
let heightAlice = 1.72
let heightBobby = 1.92
let bobbyIsTaller = heightBobby > heightAlice
print(bobbyIsTaller)

// Output
// true
```

### Оператор больше или равно (`>=`)

Можно проверить, больше или равно значение `a` значению `b` с помощью оператора "больше или равно" (`a >= b`).

```swift
let distanceKilometers = 2.7
let distanceMiles = distanceKilometers / 1.60934
print(distanceMiles >= 3.0)

// Output
// false
```

### Пример

```swift
var a = 5, b = 2

// equal to operator
print(a == b)

// not equal to operator
print(a != b)

// greater than operator
print(a > b)

// less than operator
print(a < b)

// greater than or equal to operator
print(a >= b)

// less than or equal to operator
print(a <= b)

// Output
// false
// true
// true
// false
// true
// false
```

> Примечание. Операторы сравнения используются при принятии решений в управлении потоком: ветвлениях и циклах.

### Операторы идентичности и не идентичности (`===`, `!==`)

В связи с тем, что классы представляют ссылочные типы, для сравнения экземпляров класса используется оператор идентичности - `===`, `!==`:

```swift
class Person{
     
    var name: String
    var age: Int
    init(name: String, age: Int){
         
        self.name = name
        self.age = age
    }
}
 
var tom: Person = Person(name: "Tom", age: 24)
var bob = tom
var anotherTom: Person = Person(name: "Tom", age: 24)
 
bob === tom     // true - ссылка на один и тот же объект
anotherTom === tom  // false - ссылка на разные объекты
```

Так как переменные `bob` и `tom` хранят ссылку на один и тот же объект в памяти, то оператор идентичности возвратит значение `true`.

Зато переменная `anotherTom` хранит ссылку на другой объект в памяти, не смотря на то, что ее свойства хранят те же значения, что и свойства в переменной `tom`. Но поскольку ссылки разные, то оператор идентичности возвратит значение `false`.

В противоположность оператору идентичности, который возвращает `true` в случае равенства ссылок, в Swift также есть оператор `!==`, который возвращает `true` если ссылки не равны.

### Оператор соответствия шаблону (`~=`)

Оператор соответствия шаблону `~=` вернёт логическое значение при проверке условия соответствия значения шаблону.

В большинстве случаев сопоставление с образцом работает как проверка на равенство, за исключением `Ranges`, где оно проверяет «содержится» ли значение в диапазоне.

За операцией сопоставления с образцом Swift использует оператор `~=`, который перегружен для большинства стандартных типов. При использовании сопоставления с образцом Swift ищет оператор `~=` для текущих типов. Вот пример того, как оператор `~=` ищет тип String.

```swift
func ~= (pattern: String, value: String) -> Bool {
    return pattern == value
}
```

Пример

```swift
var age = 19

if 1...18 ~= age {
    print("Too young")
} else {
    print("OK")
}

// Output
// OK
```

В этом примере задана переменная `age`, которая имеет значение `19`. Дальше происходит проверка: соответствует ли значение переменной `age` шаблону `1...18`. Так как значение переменной входит в указаное условие (есть в указанном диапазоне), то выполняется соответствующий код - `print("OK")`. Теперь изменим значение переменной `age` на `17`:

```swift
age = 17

if 1...18 ~= age {
    print("Too young")
} else {
    print("OK")
}

// Output
// Too young
```

Условие `1...18 ~= age` вернёт значение `false`, так как теперь переменная `age` не соответствует шаблону. В результате выполняется соответствующий код - `print("Too young")`.

Сопоставление с образцом — это проверка заданной последовательности токенов на наличие составляющих некоторого образца. Давайте рассмотрим простую операцию сопоставления строк.

```swift
let message = "Hello World!"

switch message {
    case "Hello": print("hello")
    case "World": print("world")
    case "Hello World!": print("Hello World!")
    default: break
}

// Output
// Hello World
```

Этот код напечатает сообщение `Hello World!` в консоли.

Внутри оператора `switch` используется как раз сопоставление с образцом.

Можно легко перегрузить оператор `~=`, чтобы изменить его поведение.

Например, в коде ниже мы меняем реализацию на пользовательскую, где вместо проверки на равенство сопоставляем с содержанием в шаблоне, и теперь вы увидите сообщение `Hello` в консоли.

```swift
func ~= (pattern: String, value: String) -> Bool {
    return value.contains(pattern)
}

let message = "Hello World!"

switch message {
    case "Hello": print("Hello")
    case "World": print("world")
    case "Hello World!": print("Hello World!")
    default: break
}

// Output
// Hello
```

Еще одним хорошим вариантом перегрузки оператора сопоставления с образцом могут быть регулярные выражения.

```swift
struct Regex {
    let pattern: String

    static let email = Regex(pattern: "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}")
    static let phone = Regex(pattern: "([+]?1+[-]?)?+([(]?+([0-9]{3})?+[)]?)?+[-]?+[0-9]{3}+[-]?+[0-9]{4}")
}

extension Regex {
    static func ~=(regex: Regex, text: String) -> Bool {
        return text.range(of: regex.pattern, options: .regularExpression) != nil
    }
}
```

Здесь есть структура `Regex`, которая имеет только одно поле, и это строка шаблона. Также реализуем статические константы электронной почты (`email`) и телефона (`phone`) с предопределенными регулярными выражениями.

Затем перегружаем оператор `~=`, в этом случае он сопоставляет текст с структурой `Regex`, используя метод `range of` строкового типа. Это все, что нужно, чтобы использовать тип `Regex` для сопоставления с образцом. Вот пример использования.

```
let email = "cmecid@gmail.com"

switch email {
    case Regex.email: print("email")
    case Regex.phone: print("phone")
    default: print("default")
}

// Output
// email
```

## 4. Логические операторы (Logical Operators)

Логические операторы используются для проверки того, является ли выражение истинным (`true`) или ложным (`false`). Они используются при принятии решений. Например,

```swift
var a = 5, b = 6
print((a > 2) && (b >= 6))

// Output
// true
```

Здесь `&&` является логическим оператором `И`. Поскольку оба выражения и `a > 2`, и `b >= 6` верны (`true`), результат верен (`true`).

Оператор       | Символ | Описание                                       | Пример
:--------------|:------:|:-----------------------------------------------|:---------:
Логическое И   | `&&`   | истина, только если оба операнда истинны       | `true && false = false`
Логическое ИЛИ | `\|\|` | истина, если хотя бы один из операндов истинен | `true \|\| false = true`
Логическое НЕ  | `!`    | истина, если операнд ложен, и наоборот         | `!true = false`

Логические операторы используются для объединения двух логических значений для получения одного логического значения. Операнды логических операторов могут иметь только логический тип данных (`Bool`) и соответственно значения - `true` или `false`.

Чтобы понять, что это значит, давайте напишем предложение: «Если это солнечный день и если это жаркий день, пойдем на пляж».

Теперь давайте разделим соответствующие части предложения на три части:

- Если это солнечный день
- И
- если это жаркий день

Только если оба этих логических выражения верны, мы идем на пляж. Если одно или оба из них ложны, мы не пойдем на пляж.

В Swift вы можете переформулировать предложение, например, следующим образом:

```swift
var isSunny = true
var isHot = false
var beachTime = isSunny && isHot
print(beachTime)

// Output:
// false
```

Is sunny | Is hot | Is sunny and is hot (beach time)
:-------:|:------:|:-------------------------------:
false    | false  | false
false    | true   | false
true     | false  | false
true     | true   | true

Эта таблица истинности рассматривает все возможные комбинации типов погоды.

### Логическое И (`&&`)

Имея два логических выражения `A` и `B`, которые могут быть либо истинными, либо ложными, вот таблица истинности для оператора И (`&&`):

A     | B     | A && B
:----:|:-----:|:------:
false | false | false
false | true  | false
true  | false | false
true  | true  | true

Результат оператора И (`&&`) может быть **истинным (true)** только в том случае, если оба логических выражения **истинны (true)**.

### Логическое ИЛИ (`||`)

Имея два логических выражения `A` и `B`, которые могут быть либо истинными, либо ложными, вот таблица истинности для оператора ИЛИ (`||`):

A     | B     | A \|\| B
:----:|:-----:|:------:
false | false | false
false | true  | true
true  | false | true
true  | true  | true

Результат оператора ИЛИ (`||`) может быть **истинным (true)** только в том случае, если хотя бы одно логическое выражение **истинно (true)**. Результат оператора ИЛИ может быть **ложным (false)** только в том случае, если ни одно из логических выражений не является **истинным (true)**.

### Логическое НЕ (`!`)

Для данного единственного логического выражения `A`, которое может быть либо истинным, либо ложным, вот таблица истинности для оператора НЕ (`!`):

A     | !A
:----:|:-----:
false | true
true  | false

Оператор НЕ (`!`) превращает истину в ложь и наоборот.

### Примеры с логическими операторами

Пример. Создадим два логических значения `isStudying` и `isWorking` и определим, занят человек или нет:

```swift
var isStudying = true
var isWorking = false
var isBusy = isStudying || isWorking
print(isBusy)

// Output
// true
```

В этом примере человеку достаточно либо работать, либо учиться, чтобы быть занятым. Человек не занят только тогда, когда он не учится и не работает.

Рассмотрим пример использования оператора NOT.

```swift
var isSunny = true
var notSunny = !isSunny
print(notSunny)

// Output
// false
```

Здесь оператор НЕ изменил значение логического значения `isSunny` на обратное. Если оно истинно, оператор НЕ делает его ложным и наоборот.

И ещё пример

```swift
// logical AND
print(true && true)
print(true && false)

// logical OR
print(true || false)

// logical NOT
print(!true)

// Output
// true
// false
// true
// false
```

> Примечание. Логические операторы используются при принятии решений в управлении потоком: ветвлениях и циклах. В вышеприведенном примере, в зависимости от выполнения условия логического выражения вернется логический результат и выведется на консоль.

## 5. Побитовые операторы (Bitwise Operators)

В Swift побитовые операторы используются для выполнения операций над отдельными битами.

| Оператор | Описание                                                            |
|:--------:|:-------------------------------------------------------------------:|
| `&`      | Бинарное (Двоичное) И (Binary AND)                                  |
| `\|`     | Бинарное (Двоичное) ИЛИ (Binary OR)                                 |
| `^`      | Бинарное (Двоичное) И (Binary XOR)                                  |
| `~`      | Бинарное (Двоичное) дополнение до единицы (Binary One's Complement) |
| `<<`     | Бинарный (Двоичный) сдвиг влево (Binary Shift Left)                 |
| `>>`     | Бинарный (Двоичный) сдвиг вправо (Binary Shift Right)               |

Побитовые операторы редко используются в повседневном программировании.

Операции с побитовыми операторами рассмотрены в отдельной статье - "Побитовые операторы".

Более детально про побитовые операторы можно узнать в отдельной статье. См. ссылки внизу.

## 6. Другие операторы

Вот список других операторов, доступных в Swift.

Оператор                | Символ | Описание                                    | Пример                |
:-----------------------|:------:|:-------------------------------------------:|:---------------------:|
Тернарный оператор      | `? :`  | Возвращает значение на основе условия | `(5 > 2) ? "Success" : "Error"`</br>Вернёт `Success`
Nil-Coalescing Operator | `??`   | Проверяет, содержит ли необязательный параметр значение или нет. | `number ?? 5`
Оператор диапазона      | `...`  | Определяет диапазон, содержащий значения | `1...3` // диапазон, содержащий значения 1, 2, 3
Операторы приведения типов | `is` `as` `as?` `as!`| Рассматривает один тип данных как другой | `if home is Castle {}`

### Тернарный оператор (`? :`)

В Swift есть один тернарный оператор, который называется **тернарный условный оператор**. Он взаимодействует с тремя операндами.

Тернарный оператор можно использовать для замены оператора `if...else` в определенных сценариях в условных конструкциях.

Тернарный оператор оценивает условие и выполняет блок кода на основе условия. Его синтаксис

```swift
<condition> ? <expression1> : <expression2>
```

Здесь тернарный оператор оценивает `условие` (`condition`) и

- если условие истинно, выполняется `выражение1` (`expression1`);
- если условие ложно, выполняется `выражение2` (`expression2`).

Тернарный оператор принимает 3 операнда (`condition`, `expression1` и `expression2`). Отсюда и название тернарный оператор.

Пример (тернарный оператор Swift):

```swift
// program to check pass or fail
let marks = 60

// use of ternary operator
let result = (marks >= 40) ? "pass" : "fail"

print("You " + result + " the exam")

// Output
// You pass the exam
```

В приведенном выше примере использовался тернарный оператор для проверки прохождения или отказа.

Здесь, если `marks` больше или равно `40`, константе `result` присваивается значение `pass`. В противном случае - константе `result` присваивается `fail`.

### Тернарный оператор вместо `if...else`

Тернарный оператор можно использовать для замены определенных типов операторов `if...else`. Например, код с конструкцией `if...else`

```swift
// if...else to check the number is positive or negative
let num = 15
var result = ""

if (num > 0) {
     result = "Positive Number"
}
else {
     result = "Negative Number"
}

print(result)

// Output
// Positive Number
```

Можно заменить на код с тернарным условным оператором

```swift
// ternary operator to check the number is positive or negative
let num = 15

let result = (num > 0) ? "Positive Number" : "Negative Number"

print(result)

// Output
// Positive Number
```

Здесь обе программы дают одинаковый результат. Однако использование тернарного оператора делает код более читабельным и чистым.

Тернарный условный оператор возвращает значение, в отличии от конструкции `if...else`. В примере выше константе `result` присваивается значение, которое возвращает тернарный оператор в зависимости от выполнения условия.

> Внимание. Тернарный условный оператор использует **три операнда**. Это значит, что заменить простую проверку условия `if` нельзя. Необходимо всегда указывать выражение, если условие не выполняется (блок `else`).

### Вложенные тернарные операторы

Можно использовать один тернарный оператор внутри другого тернарного оператора. В Swift это называется **вложенным тернарным оператором**. Например,

```swift
// program to check if a number is positive, zero, or negative
let num = 7

let result = (num == 0) ? "Zero" : ((num > 0) ? "Positive" : "Negative")

print("The number is \(result).")

// Output
// The number is Positive.
```

В приведенном выше примере используется вложенный тернарный оператор `((num > 0) ? "Positive" : "Negative")` выполняется, если условие `num == 0` ложно.

> Примечание. Не рекомендуется использовать вложенные тернарные операторы, так как они усложняют чтение и понимание кода.

Более детально про управление потоком можно узнать в отдельной статье. См. ссылки внизу.

### Оператор объединения nil (Nil-Coalescing Operator) (`??`)

В языке существуют опциональные типы данных, которые могут иметь значение или не иметь. Для того, чтоб воспользоваться этим значением - необходимо развернуть опционал. Есть несколько способов для разворачивания опционала и один из них - **объединение nil**.

Оператор объединения nil в Swift помогает решить задачу с разворачиванием опционала. Синтаксис написания следующий:

```swift
<optional parametr> ?? <default value>
```

Оператор объединения nil работает следующим образом:

- либо разворачивает опциональный параметр, если он имеет значение,
- либо подставляет значение по умолчанию, если опциональный параметр пуст (не имеет значения).

Вот пример:

```swift
let name: String? = nil
let unwrappedName = name ?? "Anonymous"
```

Поскольку `name` является опциональной строкой, необходимо безопасно развернуть ее, чтобы убедиться, что она имеет осмысленное значение. Оператор объединения nil (`??`) делает именно это, но если обнаруживает, что необязательное значение не имеет значения, вместо этого используется значение по умолчанию. В этом случае по умолчанию используется `"Anonymous"`. Это означает, что `unwrappedName` имеет тип данных `String`, а не `String?`, потому что можно гарантировать, что он имеет значение.

Не нужно создавать отдельную переменную для использования `объединения nil`. Например, это тоже отлично работает:

```swift
print("Hello, \(name ?? "Anonymous")!")
```

В этом примере в консоль выведется сообщение, в котором подставиться значение переменной `name`, если удасться развернуть опциональное значение. В противном случае - подставиться значение по умолчанию "Anonymous".

Оператор объединения nil - это оператор для возврата значений по умолчанию, если конкретная переменная не имеет значение (значение равно nil).

```swift
var identity: String? = nil
var nonNillableIdentity: String = identity ?? "Jane Doe"
print(nonNillableIdentity)

// Output
// Jane Doe

identity = "Denis Short"
print(nonNillableIdentity)

// Output
// Jane Doe
```

Поскольку у переменной `identity` значения нет (равно `nil`), возвращаем значение по умолчанию `"Jane Doe"` и сохраняем его в переменной `nonNilalbleIdentity`.

Как видно из примера, после того, как значение переменной `identity` изменилось, значение `nonNillableIdentity` не меняется автоматически. Значение `nonNillableIdentity` остается таким же, как и при инициализации - `"Jane Doe"`. Его можно изменить только обратившись напрямую к переменной `nonNillableIdentity`

```swift
nonNillableIdentity = "Mike Medison"
print(nonNillableIdentity)

// Output
// Mike Medison
```

Более детально про опциональные типы данных можно узнать в отдельной статье. См. ссылки внизу.

### Оператор диапазона (`...`, `..<`)

Диапазон представляет собой набор значений, который определяется начальной и конечной точкой. Диапазоны бывают полуоткрытые (Range) и закрытые (ClosedRange).

По типу данных диапазоны относятся к структурам.

**Полуоткрытый диапазон (Range)** - полуоткрытый интервал от нижней границы до верхней границы, но не включая ее.

**Закрытый диапазон (ClosedRange)** - интервал от нижней границы до верхней границы включительно.

Экземпляр полуоткрытого диапазона создается с помощью оператора полуоткрытого диапазона (`..<`):

```swift
let underFive = 0.0..<5.0
```

Экземпляр закрытого диапазона создается с помощью оператора полуоткрытого диапазона (`...`):

```swift
let throughFive = 0...5
```

Они в основном используются с массивами/строками для извлечения подмассивов/строк.

```swift
var array = [1,2,3,4,5]
let a = array[1...3] // [2,3,4]
let b = array[1..<3] // [2,3]
let c = array[2...] // [3,4,5]
let d = array[...3] // [1,2,3,4]
```

Более детально про диапазоны можно узнать в отдельной статье. См. ссылки внизу.

### Операторы приведения типов (`is`, `as`, `as?`, `as!`)

Приведение типов используется для взаимодействия с экземпляром определенного класса, как с частью другого подкласса или суперкласса в той же иерархии классов.

Можно использовать 4 различных типа операторов:

- `is` — для проверки типа.
- `as` - для восходящего преобразования.
- `as!` - для принудительного нисходящего преобразования.
- `as?` - для опционального нисходящего преобразования.

Более детально про приведение типов можно узнать в отдельной статье. См. ссылки внизу.

## Порядок выполнения операторов

Часто при программировании кода выражения включают в себя более одного оператора. Для корректной работы вычислений и программы необходимо, чтоб операции выполнялись в определённой последовательности.

Префиксные и постфиксные операторы не имеют порядка, они сразу меняют значение своего операнда.

Для инфиксных операторов важен порядок из выполнения.

Порядок выполнения операций выполняется согласно приоритетов операторов и их ассоциативности.

Приоритет указывает, какие операторы выполняются раньше (с более высоким приоритетом).

Ассоциативность указывает направление выполнения операций в случае, если у операторов одинаковый приоритет. Например, операторы умножения и деления имеют одинаковый приоритет и левую ассоциативность. Это значит порядок их выполнения будет слева направо.

```swift
6 / 2 * 3
```

Сначала будет операция деления, потом умножения.

Можно группировать выполнение операций круглыми скобками (`()`)

```swift
print(6 + 2 * 3)
print((6 + 2) * 3)

// Output
// 12
// 24
```

Для основных операций порядок выполнения следующий: арифметика -> сравнение -> логика.

- арифметика - это арифметические операции. Порядок такой же, как и могли изучить в школе: сначала операции умножения, деления, и затем - сложения, вычитания.
- сравнение - операции с использованием операторов сравнения, которые возвращают логическое значение `true` или `false`.
- логика - логические операции с операторами *логического И* и *логического ИЛИ*. Они принимают и возвращают логические значения.

Пример

```swift
print(6 + 5 < 13 - 9 && 18 * 2 > 120)

// Output
// false
```

Порядок выполнения следующий:

- базовое выражение
    - `6 + 5 < 13 - 9 && 18 * 2 > 120`
- выполнятся арифметические операции
   - `11 < 4 && 36 > 120`
- выполнятся операции сравнения
   - `false && false`
- выполнятся логические операции
   - `false`

Пример

```swift
print((!(true && false) || !(false || true)) && !(false && true))

// Output
// true
```

Порядок выполнения следующий:

- `(!(true && false) || !(false || true)) && !(false && true)`
- `(!false || !true) && !false`
- `(true || false) && true`
- `true && true`
- `true`

В таблице ниже сгруппирована информация, которая указана выше по приоритетам и ассоциативности операторов Swift. Чем выше находится оператор в таблице, тем выше его приоритет.

Оператор           | Группа                       | Пример      | Ассоциативность
:------------------|:-----------------------------|:-----------:|:---
Побитовый сдвиг    | BitwiseShiftPrecedence       | `>>` `<<`   | нет (none)
Мультиплицирование | MultiplicationPrecedence     | `*` `/` `%` | левая (left)
Добавление         | AdditionPrecedence           | `\|` `&` `^` `+` `-` | левая (left)
Диапазон           | RangeFormationPrecedence     | `..<` `...` | нет (none)
Приведение типа    | CastingPrecedence            | `is` `as`   | нет (none)
Nil-Coalescing     | NilCoalescingPrecedence      | `??`        | правая (right)
Сравнение          | ComparisonPrecedence         | `==` `===` `!=` `>` `<` `>=` `<=` | нет (none)
Логическое И       | LogicalConjunctionPrecedence | `&&`        | левая (left)
Логическое ИЛИ     | LogicalDisjunctionPrecedence | `\|\|`      | левая (left)
Пользовательские операторы | DefaultPrecedence            |             | нет (none)
Тернарный оператор | TernaryPrecedence            | `? :`       | правая (right)
Присваивания       | AssignmentPrecedence         | `=` `*=` `/=` `%=` `+=` `-=` | правая (right)

Более детально про приоритет операторов и ассоциативность можно узнать в отдельной статье. См. ссылки внизу.

## Перегрузка операторов. Пользовательские операторы

При программировании бывают случаи, когда либо действия существующего оператора не удовлетворяет потребности, либо необходимо добавить новый оператор для определенной операции.

Поэтому можно перезаписать существующий оператор (перегрузка оператора, Operator Overloading) или создать свой оператор.

Пример (оператор считает сумму квадратов двух чисел):

```swift
infix operator +^

func +^(lhs: Double, rhs: Double) -> Double {
    return lhs * lhs + rhs * rhs
}
print(2 +^ 3)

// Output
// 13.0
```

Пример (постфиксный оператор возвращает значение числа в третей степени):

```swift
postfix operator ^^^

postfix func ^^^(lhs: Double) -> Double {
    return lhs * lhs * lhs
}
print(2^^^)

// Output
// 8.0
```

Более детально про перегрузку операторов и пользовательские операторы можно узнать в отдельной статье. См. ссылки внизу.

---

## Еще полезные ссылки

- [Переменные и константы](https://robot.obo.dev/read/posts/variable/)
- [Литералы](https://robot.obo.dev/read/posts/literal/)
- [Приоритет операторов и ассоциативность](https://robot.obo.dev/read/posts/operator-precedence/)
- [Побитовые операторы](https://robot.obo.dev/read/posts/operator-bitwise/)
- [Перегрузка операторов. Пользовательские операторы](https://robot.obo.dev/read/posts/operator-custom/)
- [Типы данных](https://robot.obo.dev/read/posts/data-type/)
- [Литералы](https://robot.obo.dev/read/posts/literal/)
- [Опционалы](https://robot.obo.dev/read/posts/optional-data-type/)
- [Диапазоны](https://robot.obo.dev/read/posts/range/)
- [Управление потоком](https://robot.obo.dev/read/posts/flow-control/)
- [Функции](https://robot.obo.dev/read/posts/function/)
- [Приведение типов](https://robot.obo.dev/read/posts/type-casting/)

Также информацию по операторам можно получить на странице официальной документации.

Ссылки на официальную документацию:

- [Swift.org - Basic Operators](https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html)
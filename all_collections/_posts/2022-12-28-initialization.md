---
layout: post
title: Инициализаторы и деинициализаторы
date: 2022-12-28
categories: ["Swift", "SPL"]
---

# Инициализаторы и деинициализаторы

**Инициализатор** — это специальный метод, выполняющий подготовительные действия при создании экземпляра объектного типа данных. Инициализатор срабатывает при создании экземпляра, а при его удалении вызывается **деинициализатор**.

Деинициализаторы же являются отличительной особенностью классов. Деинициализатор автоматически вызывается во время уничтожения экземпляра класса.

---

# Инициализация

В языке Swift для выполнения операций с переменными (константами) эти переменные (константы) должны иметь какие-то значения. При объявлении переменной (константы) есть этап инициализации.
 
В простом объяснении, инициализация - это присвоение начального значения переменной или константе.

```swift
var title = "Some Title"
```

В этом примере объявлена переменная с именем `title` и проинициализарована со значением `"Some Title"`.

Так как базовые типы данных относятся к структурам, то при инициализации создаётся экземпляр определённой структуры с определённым значением.

В приведенном выше примере, при объявлении переменной `title` был создан экземпляр структуры `String`.

При этом переменные (константы) могут быть созданы не только с базовыми типами данных, а и с более сложными, такими как структуры, классы, перечисления.

Поэтому перейдём к более полному определению инициализации.

**Инициализация** - это процесс подготовки экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться.

Инициализатор — это специальная функция, которая используется для создания объектов определенного класса, структуры или перечисления.

Инициализаторы иногда называют **конструкторами**, потому что они «конструируют» объекты.

В отличии от инициализаторов в языке Objective-C, инициализаторы в Swift не возвращают значения. Основная роль инициализаторов - убедиться в том, что новый экземпляр типа правильно инициализирован до того, как будет использован в первый раз.

### Подготовка экземпляра. Установка начальных значений для свойств хранения

Классы и структуры должны устанавливать начальные значения у всех свойств хранения (Stored property) во время создания экземпляра класса или структуры. Свойства хранения не могут находиться в неопределённом состоянии.

Начальное значение свойства можно установить или через присваивания ему значение по умолчанию, как часть определения свойства, или установить значение с помощью инициализатора (внутри инициализатора).

При присваивании свойствам значений по умолчанию, инициализатор проверяет наличие значений у свойств и подготавливает экземпляр к дальнейшей работе. При этом, инициализатор может изменить значения по умолчанию свойствам, у которых эти значения установлены и установить значения тем свойствам, у которых значения не установлены.

> Заметка. При присваивании значения по умолчанию свойству хранения или установке исходного значения в инициализаторе - значение устанавливается напрямую, без вызова наблюдателей свойств. Наблюдатели свойств вызываются в дальнейшем при изменении значения свойства.

Также, начальное значение свойства можно указать в виде функции или замыкания. Этот способ показан в статье ниже.

## Инициализатор

Как сказано выше, инициализатор — это особый тип функции, который используется для создания объекта класса, структуры или перечисления. Так как он объявляется внутри  

В языке Swift инициализатор (конструктор) — это специальный метод `init()`, выполняющий подготовительные действия при создании экземпляра объектного типа данных.

Инициализатор выполняет установку начальных значений хранимых свойств и различных настроек, которые нужны для использования экземпляра.

В самой простой своей форме инициализатор указывается как метод экземпляра с именем `init` без параметров:

```swift
init() {
    // инициализация проводится тут
}
```

- Имя инициализатора `init` является специальным (ключевым) и оно не меняется;
- Инициализатор может иметь или не иметь входящих параметров;
- Инициализатор не возвращает никакого значения.

Посмотрим на пример. Создадим структуру с именем `Book`, которая имеет 3 свойства: `title`, `author` и `pages`.

```swift
struct Book {
    var title: String = ""
    var author: String = ""
    var pages: Int = 0
}
```

В этом примере инициализатор не указан, так как при инициализации используются значения свойств по умолчанию. Данный код можно записать в виде:

```swift
struct Book {
    var title: String = ""
    var author: String = ""
    var pages: Int = 0

    init() {}
}
```

Здесь инициализатор проверяет наличие значений у свойств (они указаны по умолчанию) и подготавливает экземпляр структуры к дальнейшей работе.

Так же можно перенести присваивания значений по умолчанию свойствам в инициализатор

```swift
struct Book {
    var title: String
    var author: String
    var pages: Int

    init() {
        title = ""
        author = ""
        pages = 0
    }
}
```

Здесь, при объявлении свойств указан только их тип. А присваивания начальных значений указано в инициализаторе.

Создадим экземпляр структуры `Book`:

```swift
var lotrOne = Book.init() // полная форма записи
var lotrTwo = Book() // сокращенная форма записи

print(lotrOne.pages)
print(lotrTwo.pages)

// Output
// 0
// 0
```

В приведенном выше коде первая строка использует инициализатор `Book.init()` для создания объекта типа `Book`. Так как инициализатор - это функция, то для доступа использовался синтаксис "dot notation".

Во второй строке использовалась сокращённая форма записи - можно не указывать `.init()`, а просто указать круглые скобки `()` после имени типа. 

Можно сказать, что мы "инициализировали" объекты структуры `Book` и присвоили их переменным `lotrOne` и `lotrTwo`.

> Проще всего запомнить, что вызов инициализатора (в сокращённой форме записи) похож на вызов любой другой функции, за исключением того, что имя функции совпадает с именем типа.

Пример с классом:

```swift
class Wall {
    ...

    // create an initializer 
    init() {
        // perform initialization
        ... 
    }
}
```

Здесь метод `init()` является инициализатором класса `Wall`.

```swift
// declare a class
class  Wall {
    var length: Double

    // initializer to initialize property
    init() {
        length = 5.5
        print("Creating a wall.")
        print("Length = ", length)
    }
}

// create an object
var wall1 = Wall()

// Output
// Creating a wall.
// Length = 5.5
```

В приведенном выше примере создали инициализатор с именем `init()`. Внутри инициализатора мы инициализировали значение свойства `length`.

В инициализатор кроме инструкций, которые инициализируют свойства, можно размещать и другие инструкции, как и в обычной функции. В этом примере кроме инициализации свойства дополнительно выводятся в консоль две строки.

Обратите внимание на следующее выражение:

```swift
// create an object
var wall1 = Wall()
```

Здесь, когда создается объект `wall1`, вызывается инициализатор `init()`. И значение свойства длины инициализируется равным `5.5`.

### Инициализатор с параметрами (Параметризованный инициализатор, Parameterized Initializer)

Инициализатор Swift также может принимать один или несколько параметров. Такие инициализаторы известны как параметризованные инициализаторы (инициализаторы с параметрами).

Можно передать параметры инициализации как часть определения инициализатора, для определения типов и имен значений, которые настраивают процесс инициализации. Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода.

Таким образом, можно настроить работу инициализатора для присваивания значений тем свойствам, у которых не установлены значения по умолчанию либо переопределить значения по умолчанию тем свойствам, у которых такие значения установлены.

```swift
struct Book {
    var title: String = ""
    var author: String = ""
    var pages: Int = 0
 
    init(title: String) {
        self.title = title
    }
}
```

- Внутри класса или структуры инициализатор имеет специальное имя — `init()`.
- Приведенный выше инициализатор имеет один параметр `title` типа `String`.
- Внутри инициализатора присваиваем значение параметра `title` свойству `title`.
- Оператор `self` указывает на экземпляр структуры `Book`. Таким образом выражение `self.title` относится к свойству `title` структуры `Book`.

Внутри структуры `Book` инициализатор (метод `init()`) используется для настройки инициализации объекта `Book`.

Вне структуры - используется `Book()` для инициализации объекта `Book`.

```swift
var lotr = Book(title: "Братство Кольца")
lotr.pages = 479
lotr.author = "Толкин"
 
print(lotr.title)

// Output
// Братство кольца
```

В этом примере был создан объект структуры `Book` и присвоен переменной `lotr`. При инициализации был передан параметр `title: "Братство Кольца"` в инициализатор. В результате выполнения инициализации свойству `title` экземпляра структуры `Book` было присвоено значение `"Братство Кольца"`.

Давайте рассмотрим ещё пример,

```swift
class Wall {
    var length: Double
    ...

    // initializer with parameter
    init(length: Double) {
        self.length = length
    }
}

// create an object
var wall1 = Wall(length: 10.5)
```

Здесь,

- `init(length: Double)` - инициализатор с параметром `length`; 
- `var wall1 = Wall(length: 10.5)` - передать значение `10.5` в параметр `length`;
- `self.length = length` — присваивает значение параметра `length` (`10.5`) свойству `length`;
- `self.length` - указывает, что свойство `length` связано с текущим объектом, который является `wall1`.

Теперь дополним этот пример:

```swift
// declare a class
class Wall {
    var length: Double
    var height: Double

    // parameterized initializer to initialize properties
    init(length: Double, height: Double) {
        self.length = length
        self.height = height
    }

    func calculateArea() -> Double {
        return length * height
    }
}

// create object and initialize data members
var wall1 = Wall(length: 10.5, height: 8.6)
var wall2 = Wall(length: 8.5, height: 6.3)

print("Area of Wall 1: ", wall1.calculateArea())
print("Area of Wall 2: ", wall2.calculateArea())

// Output
// Area of Wall 1: 90.3
// Area of Wall 2: 53.55
```

В приведенном выше примере создали инициализатор `init()` с двумя параметрами: `length` и `height`. Обратите внимание на выражения,

```swift
var wall1 = Wall(length: 10.5, height: 8.6)
var wall2 = Wall(length: 8.5, height: 6.3)
```

Здесь при создании объекта класса `Wall` передаем значения свойств члена в качестве аргументов.

Теперь, когда свойства инициализированы, можем вычислить площадь стены с помощью метода `calculateArea()`.

### Перегрузка инициализатора (Initializer Overloading)

Инициализаторы Swift могут быть перегружены аналогично перегрузке функций.

При перегрузке инициализатора два или более инициализатора могут иметь одно и то же имя, если они имеют разные типы или количество параметров.

И на основании аргументов, переданных при создании объекта, вызывается соответствующий инициализатор.

Давайте посмотрим пример:

```swift
class Person {
    var age: Int

    // 1. initializer with no arguments
    init() {
        age = 20
    }

    // 2. initializer with an argument
    init(age: Int) {
        self.age = age
    }

    // method to return age
    func getAge() -> Int {
        return age
    }
}

var person1 = Person()
var person2 = Person(age: 23)

print("Person1 Age: ", person1.getAge())
print("Person1 Age: ", person2.getAge())

// Output
// Person1 Age: 20
// Person1 Age: 23
```

В приведенном выше примере был создан класс `Person` с одним свойством `age`.

Также определили два инициализатора: `init()` и `init(age: Int)`.

- Если не передаём никаких аргументов объекту `person1`, то вызывается первый инициализатор. Следовательно, свойство `age` инициализируется со значением равным `20`.
- Если передаём `23` в качестве аргумента `person2`, то вызывается второй инициализатор, и свойство `age` инициализируется со значением `23`.

Метод `getAge()` возвращает значение `age`, и используем его для вывода возраста `person1` и `person2`.

### Локальные и внешние имена параметров

Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные (внутренние) имена для использования внутри тела инициализатора и внешние для использования при вызове инициализатора.

Однако инициализаторы не имеют своего имени, как это имеют методы или функции. Имя инициализатора может быть только `init`. Поэтому имена и типы параметров инициализатора играют важную роль в определении того, какой инициализатор и где может быть использован.

Swift предоставляет автоматические внешние имена для каждого параметра. Но можно указать свое внешнее имя.

Следующий пример определяет структуру `Color` с тремя постоянными свойствами `red`, `green`, `blue`. Эти свойства имеют значения от `0.0` до `1.0`, для индикации количества соответствующего цвета.

Структура `Color` имеет два инициализатора:

- `init(red: Double, green: Double, blue: Double)` - инициализатор с тремя параметрами `red`, `green`, `blue` типа `Double` (компоненты цвета красного, зеленого, синего);
- `init(white: Double)` - инициализатор с одним параметром `white`, который нужен для предоставления значения для всех трех компонентов цвета.

```swift
struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }

    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
```

Оба инициализатора могут быть использованы для создания нового экземпляра `Color`, передав значения в каждый параметр инициализатора:

```swift
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
```

Важно! Невозможно вызвать инициализатор без использования внешних имен. Внешние имена обязательно должны быть использованы в инициализаторе, если они определены, если пропустить их, то выскочит ошибка компиляции:

```swift
let veryGreen = Color(0.0, 1.0, 0.0)
// этот код вызовет ошибку компиляции, так как здесь нет внешних имен
```

Внешние имена параметров можно изменять, указывая такие, которые являются более информативными.

Следующий пример определяет структуру `Celsius`, которая хранит температуру в Цельсиях. Структура `Celsius` реализует три пользовательских инициализатора `init(fromCelsius: )`, `init(fromFahrenheit: )` и `init(fromKelvin: )`, которые инициализируют новый экземпляр структуры со значением температурной шкалы:

```swift
struct Celsius {
    var temperatureInCelsius: Double

    init(fromCelsius celsius: Double) {
        temperatureInCelsius = celsius
    }
    
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }

    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}

let currentTemperature = Celsius(fromCelsius: 20.0)
// currentTemperature.temperatureInCelsius is 20.0

let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0

let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
```

- Первый инициализатор имеет один параметр с внешним именем `fromCelsius` и с локальным именем `celsius`.
- Второй инициализатор имеет один параметр с внешним именем `fromFahrenheit` и с локальным именем `fahrenheit`.
- Третий инициализатор имеет один параметр с внешним именем `fromKelvin` и локальным именем `kelvin`.

Второй и третий инициализаторы конвертируют их единственный аргумент в значение по Цельсию и сохраняют это значение в свойство `temperatureInCelsius`.

### Параметры инициализатора без внешних имен

Инициализатор - это функция, поэтому если не нужно использовать внешние имена для параметров инициализации, то, как и в синтаксисе функций, следует указать подчеркивание (`_`) вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию.

Запишем пример выше, с указанием одного из инициализаторов без внешнего имени:

```swift
struct Celsius {
    var temperatureInCelsius: Double

    init(_ celsius: Double) {
        temperatureInCelsius = celsius
    }
    
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }

    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}

let bodyTemperature = Celsius(36.6)
// bodyTemperature is 36.6
```

Инициализатор вызывает `Celsius(36.6)`, для указания температуры в градусах Цельсия. Поэтому более целесообразно написать `init(_ celsius: Double)`, для того, чтобы предоставить безымянное значение типа `Double`.

### Опциональные типы свойств

В некоторых случаях значение свойства может отсутствовать либо потому, что его нельзя установить во время инициализации, либо потому, что такое свойство может не иметь значение (опциональное). В этих случаях, при объявлении таких свойств, их следует указывать с опциональным типом данных.

Свойства опционального типа автоматически инициализируются со значением `nil`, что указывает на то, что значение отсутствует на этапе инициализации.

Следующий код определяет класс `SurveyQuestion` с опциональным типом `String` свойства `response`:

```swift
class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}

let cheeseQuestion = SurveyQuestion(text: "Нравится ли вам сыр?")
cheeseQuestion.ask()

// Output
// Выведет "Нравится ли вам сыр?"
```

Ответ на вопрос не может быть известен до того, пока он не задан, так что свойство `response` должно быть типа `String?` (опциональный String). Ему автоматически присваивается значение `nil` при инициализации `SurveyQuestion`, что обозначает, что “значения пока отсутствует”.

Далее можно свойству `response` присвоить значение:

```swift
cheeseQuestion.response = "Да, я люблю сыр"
print(cheeseQuestion.response)

// Output
// Optional("Да, я люблю сыр")
```

Теперь свойство `response` имеет значение. Но это значение - опционального типа, поэтому для дальнейшей работы с ним, это значение следует извлекать из опционала.

Больше про опциональные типы данных можно прочитать в отдельной статье. См. ссылку внизу.

### Присваивание значений постоянным свойствам во время инициализации

Свойства могут быть постоянными и неизменяемыми. Для этого они объявляются как константы.

Значения неизменяемым свойствам можно присваивать в любой точке процесса инициализации. Как только для свойства (константы) присваивается значение, то это значение не может быть в дальнейшем изменено.

> Заметка. В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом.

Вы можете пересмотреть пример SurveyQuestion и использовать вместо переменного свойства text постоянное свойство text, для индикации того, что это свойство не меняется после создания SurveyQuestion. Даже если свойство является постоянным, оно все еще может быть установлено в инициализаторе класса:

```swift
class Car {
    let model: String
    // ...
    init(model: String) {
        self. model = model
        // ...
    }
}
let auto = Car(model: "BMW")
// auto.model is "BMW"
```

Для чего можно использовать постоянные свойства? Если у объекта свойство не должно менять значение. Например, у машины четыре колеса или в модели самолета определенное количество мест. 

---

Рассмотрим несколько типов инициализаторов, которые можно использовать:

- Встроенный инициализатор (Default Initializer), который будет инициализировать объект со значениями свойств по умолчанию;
- Поэлементный инициализатор (Memberwise Initializer) для структур, который будет автоматически инициализировать свойства структуры;
- Назначенный инициализатор (Designated Initializer);
- Вспомогательный инициализатор (Convenience Initializer);
- Проваливающийся инициализатор (Failable Initializer), который могут возвращать `nil` на основании параметров, предоставленных инициализатору;
- Обязательный инициализатор (Required Initializer), который обязательно должен быть реализован во всех подклассах данного класса.

При реализации собственных типов данных во многих случаях не требуется создавать собственный инициализатор, так как классы и структуры имеют встроенные инициализаторы:

- классы имеют пустой встроенный инициализатор `init() {}`;
- структуры имеют встроенный инициализатор, принимающий в качестве входных аргументов значения всех свойств.

> Примечание. Пустой инициализатор срабатывает без ошибок только в том случае, если у класса отсутствуют свойства или у каждого свойства указано значение по умолчанию.

Для опциональных типов данных значение по умолчанию указывать не требуется, оно соответствует `nil`.

## Встроенный инициализатор (Default Initializer)

Язык Swift предоставляет **встроенный (дефолтный, по умолчанию) инициализатор** для любой структуры или базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора. Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями по умолчанию.

Синтаксис встроенного инициализатора по умолчанию:

```swift
class className {
    // ...
    init() {}
}
```

Этот инициализатор не надо объявлять, он создаётся автоматически.

Рассмотрим встроенный инициализатор по умолчанию:

```swift
class Car {
    var name = ""
}
 
let tesla = Car()
tesla.name = "Tesla"
```

Так как все свойства класса `Car` имеют значения по умолчанию и так как этот класс не имеет суперкласса, то класс `Car` автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр со всеми свойствами с уже присвоенными значениями по умолчанию.

В этом примере инициализатор по умолчанию создается автоматически на основании значения по умолчанию свойства `name` класса `Car`.

В приведенном выше коде:

- был создан класс `Car` со свойством `name` типа `String`. 
- проинициализирован экземпляр класса `Car` с помощью инициализатора `Car()` и объект присваивается переменной `tesla`.
- затем устанавливается для свойства `name` новое значение `"Tesla"`.

Когда инициализируем экземпляр класса с помощью `Car()`, ему присваивается пустая строка `""`, которая является значением свойства по умолчанию.

> Важно! Для того, чтоб встроенный инициализатор правильно работал, необходимо чтоб все хранимые свойства класса имели значения по умолчанию. Для опциональных типов данных значение по умолчанию указывать не требуется, оно соответствует `nil`.

Если объявить свой пользовательский инициализатор, то встроенный инициализатор не создаётся автоматически. Чтоб сохранить его функциональность, следует его указать явно. Например:

```swift
class Car {
    var name = ""

    init() {} // Default Initializer

    init(name: String) {
        self.name = name
    }
}
```

В этом примере был указан свой инициализатор `init(name:)`. Поэтому дополнительно был указан пустой инициализатор `init()` для реализации функционала инициализации свойств со значением по умолчанию.

Если не указывать для свойств значения по умолчанию при их объявлении, то встроенный инициализатор не создаётся. В этом случае следует явно указать инициализатор. В этом случае встроенный инициализатор из примера выше можно перезаписать следующим образом:

```swift
class Car {
    var name: String
 
    init() {
        self.name = ""
    }
}
```

У свойства `name` теперь есть явная аннотация типа `String`. Инициализатор `init()` содержит код для присвоения значения по умолчанию `""` для свойства `name`. То есть в данном случае разделяем объявление свойства и его инициализацию.

Зачем использовать значения по умолчанию для свойств и инициализатор по умолчанию? Во-первых, это удобнее. Если необходимо предоставить значение по умолчанию, можно сделать ваш код более кратким. Более того, можно использовать вывод типа, а объявление свойства и его значения по умолчанию облегчают чтение кода.

## Поэлементный инициализатор (Memberwise Initializer)

**Поэлементный инициализатор** (почленный инициализатор, Memberwise Initializer) доступен только для структур. Swift будет автоматически создавать инициализатор для структур на основании свойств этой структуры, если вы не предоставите собственных инициализаторов `init()`.

Структурные типы автоматически получают **поэлементный (почленный) инициализатор**, если они не определяют своего пользовательского инициализатора. Это верно даже при условии, что хранимые свойства не имеют значений по умолчанию.

Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры.

Начальные значения для свойств нового экземпляра могут быть переданы в поэлементный инициализатор по имени.

Например создадим структуру:

```swift
struct Person {
    // define two properties
    var name: String
    var age: Int
}
```

Здесь мы не создали никакого инициализатора внутри структуры `Person`. Однако Swift автоматически генерирует для нас почленный инициализатор:

```swift
init(name: String, age: Int) {
    self.name = name
    self.age = age
}
```

Теперь создадим экземпляр структуры `Person`:

```swift
// object of Person with memberwise initializer 
var person1 = Person(name: "Dwight", age: 43)

print("Name: ", person1.name)
print("Age: ", person1.age)

// Output
// Name: Dwight
// Age: 43
```

Здесь значения внутри круглых скобок (`name: "Dwight", age: 43`) автоматически присваиваются соответствующим свойствам структуры. Это называется **поэлементным (почленным) инициализатором**.

В приведенном выше примере использовался автоматически сгенерированный поэлементный инициализатор для присвоения значений соответствующим свойствам экземпляра структуры `Person`.

Здесь был проинициализирован экземпляр структуры `Person`, у которого

- для свойства `name` установлено значение `"Dwight"`,
- для свойства `age` установлено значение `43`.

### Поэлементный инициализатор со значениями свойств по умолчанию

При создании структуры можно указать свойствам значения по умолчанию.

```swift
struct Rectangle {
    var width = 0
    var height = 0
}
 
let square = Rectangle(width: 10, height: 10)
```

У нас есть структура `Rectangle` с двумя свойствами `width` и `height` типа `Int` со значениями по умолчанию `0`. У нас есть возможность инициализировать экземпляр `Rectangle` с помощью поэлементного инициализатора.

При этом автоматически генерируются два инициализатора: `init()` и `init(width: Int, height: Int)`. Инициализатор `Rectangle(width:height:)` генерируется автоматически.

Если бы мы сами написали данный инициализатор, он бы выглядел следующим образом:

```swift
init(width: Int = 0, height: Int = 0) {
    self.width = width
    self.height = height
}
```

Можно использовать для каждого элемента инициализатор со значениями по умолчанию или без них. В этом примере использовали значения по умолчанию для свойств структуры.

Если не все свойства будут иметь значения по умолчанию, то вместо пустого инициализатора будет инициализатор с параметрами, которые передают значения свойствам без значений по умолчанию:

```swift
struct Rectangle {
    var width = 0
    var height: Int
}
```

В этом случае автоматически генерируются два инициализатора: `init(height: Int)` и `init(width: Int, height: Int)`.

Следует помнить, что:

- Поэлементный инициализатор работает только для структур, а не для классов.
- Если вы создадите свой собственный инициализатор с помощью функции `init()`, вы потеряете поэлементный инициализатор.

Преимущество использования значений по умолчанию вместе с поэлементным инициализатором заключается в том, что вы сохраняете возможность инициализировать объект без предоставления параметров:

```swift
let square = Rectangle()
square.width = 10
print(square.height)

// Output
// 0
```

## Назначенный инициализатор (Designated Initializer)

Инициализаторы класса и структуры, производящие установку значений свойств, называются **назначенными (designated) инициализаторами**. Вы можете разработать произвольное количество назначенных инициализаторов с отличающимся набором параметров в пределах одного объектного типа. 

При этом у классов должен существовать хотя бы один назначенный инициализатор, производящий установку значений всех свойств (если они существуют), и один из назначенных инициализаторов должен обязательно вызываться при создании экземпляра. В некоторых случаях, это требование удовлетворяется наследованием одного или более назначенных инициализаторов от суперкласса.

Синтаксис назначенного инициализатора:

```swift
init(<parameters>) {
    <statements>
}
```

Назначенный инициализатор объявляется с помощью имени инициализатора - ключевое слово `init`. Данный тип инициализатора также может принимать входные параметры (`<parameters>`) и устанавливать значения для свойств.

В теле инициализатора обязательно необходимо проинициализировать все хранимые свойства, у которых нет значений по умолчанию. Можно переприсвоить значения тем свойствам, у которых установлены значения по умолчанию.

Назначенные инициализаторы в дочерних классах предназначены для того, чтобы полностью инициализировать все свойства представленные классом и чтобы вызвать соответствующий инициализатор суперкласса для продолжения процесса инициализации цепочки наследований суперклассов. Вызов назначенного инициализатора суперкласса выполняется с помощью `super.init()`, куда передаются необходимые параметры.

Назначенные инициализаторы объединяют в себе все точки, через которые проходит процесс инициализации и через которые процесс инициализации идет по цепочке в суперкласс.

> Примечание. В классах инициализаторы наследуются от суперкласса к подклассу.

В классах инициализатором, который может вызывать назначенный инициализатор, может быть:

- инициализатор производного класса, вызывающий инициализатор родительского класса для установки значений наследуемых свойств;
- вспомогательный инициализатор из этого класса.

Про делегирование инициализатора для классовых типов и отношения между инициализаторами будет ниже.

Больше про наследование можно прочитать в отдельной статье. См. ссылку внизу.

> Примечание. Инициализатор может устанавливать значения констант.

Внутри инициализатора необходимо установить значения свойств класса или структуры, чтобы к концу его работы все свойства имели значения (опционалы могут соответствовать `nil`).

Пример:

```swift
class Circle {
    var radius: Double
    var circumference: Double {
        2 * .pi * radius
    }
 
    init(radius: Double) {
        self.radius = radius
    }
}
```

В приведенном выше коде определяем класс с именем `Circle`. Он имеет одно хранимое свойство `radius` типа `Double` и одно вычисляемое свойство `circumference` типа `Double`.

Класс также имеет один назначенный инициализатор, объявленный как `init(radius:)`, который присваивает параметр `radius` свойству с тем же именем.

Иными словами, мы можем создать круг, указать его радиус и получить окружность:

```swift
let earth = Circle(radius: 6371.0)
print(earth.circumference)

// Output
// 40030.17
```

## Вспомогательный инициализатор (Convenience Initializer)

Кроме назначенных инициализаторов, в языке Swift существуют **вспомогательные (convenience) инициализаторы**. Они являются вторичными и поддерживающими. Можно определить вспомогательный инициализатор для проведения настроек и обязательного вызова одного из назначенных инициализаторов из того же класса, что и вспомогательный инициализатор с некоторыми параметрами назначенного инициализатора с установленными начальными значениями.

Вспомогательные инициализаторы не являются обязательными для их реализации в типе. Следует создавать их, если это обеспечивает наиболее рациональный путь решения поставленной задачи. Создавайте вспомогательный инициализатор всякий раз, когда это является наиболее рациональным путем общей инициализации и может сэкономить время и сделать саму инициализацию класса более чистой и краткой.

Синтаксис объявления вспомогательных инициализаторов не слишком отличается от синтаксиса назначенных.

Синтаксис вспомогательного инициализатора:

```swift
convenience init(<parameters>) {
    <statements>
}
```

Вспомогательный инициализатор объявляется с помощью модификатора `convenience`, за которым следует имя инициализатора - ключевое слово `init`. Данный тип инициализатора также может принимать входные параметры (`<parameters>`) и устанавливать значения для свойств.

В теле инициализатора обязательно должен находиться вызов одного из назначенных инициализаторов. Вызов назначенного инициализатора выполняется с помощью `self.init()`, куда передаются необходимые параметры.

Объявим вспомогательный инициализатор для примера выше:

```swift
class Circle {
    var radius: Double
    var circumference: Double {
        2 * .pi * radius
    }
 
    init(radius: Double) {
        self.radius = radius
    }

    convenience init(circumference: Double) {
        self.init(radius: circumference / (.pi * 2))
    }
}
```

Приведенный выше инициализатор `init(circumference:)`, называемый вспомогательным инициализатором, принимает параметр `circumference`. Внутри тела функции окружность круга используется для вычисления его радиуса, который предоставляется назначенному инициализатору `init(radius:)`.

Таким образом, мы создали инициализатор, которым удобно пользоваться. Некоторые разработчики могут захотеть создать круг по его радиусу, а другие — по окружности круга. Это удобно!

Вспомогательный инициализатор может не просто вызывать назначенный инициализатор, а и выполнять ещё определённые инструкции. Например:

```swift
class Circle {
    var radius: Double
    var circumference: Double {
        2 * .pi * radius
    }
 
    init(radius: Double) {
        self.radius = radius
    }

    convenience init(circumference: Double) {
        self.init(radius: circumference / (.pi * 2))
        print("Current radius is \(radius)")
    }
}

let moon = Circle(circumference: 10_921)

// Output
// Current radius is 1738.131133506589
```

В результате при создании нового экземпляра класса `Circle` будет предложено выбрать один из двух инициализаторов: `init(radius:)` или `init(circumference:)`. Вспомогательный инициализатор вызывает назначенный и выводит текст на консоль.

Ещё пример

```swift
class University {
  
    var name : String
    var rank : String

    // define designated init
    init(name : String, rank: String) {
        self.name = name
        self.rank = rank
    }

    // define convenience init  
    convenience init() {
        self.init(name: "Kathmandu University", rank: "1st")
    }
}

var university1 = University()
print(university1.name)
print("Rank:", university1.rank)

// Output
// Kathmandu University
// Rank: 1st
```

В приведенном выше примере мы создали назначенный инициализатор (designated initializer): `init(name: , rank: )` и вспомогательный инициализатор (convenience initializer): `convenience init()`.

Внутри вспомогательного инициализатора мы вызвали назначенный инициализатор и присвоили значения свойствам.

```swift
convenience init() {
    self.init(name: "Kathmandu University", rank: "1st")
}
```

При создании объекта `university1` вызывается вспомогательный инициализатор.

```swift
// using convenience initializer
var university1 = University()
```

Это делает наш код более чистым по сравнению с вызовом назначенного инициализатора:

```swift
// call designated initializer
var university1 = University(name: "Kathmandu University", rank: "1st")
```

> Примечание. Вспомогательные инициализаторы полезны, когда речь идет о назначении значений по умолчанию для сохраненных свойств.

Каждый класс должен иметь хотя бы один или несколько назначенных инициализаторов. Класс также может иметь один или несколько вспомогательных инициализаторов, и они обычно используются в сценарии, в котором добавление вспомогательного инициализатора экономит ваше время или делает ваш код более простым в использовании.

Почему мы просто не создали еще один назначенный инициализатор?

```swift
init(circumference: Double) {
    self.radius : circumference / (.pi * 2)
}
```

В этом случае получили бы два назначенных инициализатора, которые могли бы нормально работать. Однако, создав вспомогательный инициализатор, можно делегировать инициализацию указанному инициализатору.

Как будто вспомогательный инициализатор говорит назначенному инициализатору: «Смотри, ты делаешь тяжелую работу, я здесь просто для удобства!».

Преимущества делегирования инициализатора становятся более понятными при создании подклассов.

## Делегирование инициализатора

Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. Этот процесс называется как *делегирование инициализатора*. Он позволяет избегать дублирования кода в разных инициализаторах.

### Делегирование инициализатора для типов значения (Value Type)

Типы значений (структуры и перечисления) не поддерживают наследование, так что их процесс делегирования инициализатора сравнительно прост, потому что они только могут делегировать другому инициализатору то, что предоставляют сами.

Для типов значений используется `self.init()` для ссылки на остальные инициализаторы одного и того же типа значения, когда вы пишете свои инициализаторы. Можно вызывать `self.init()` из инициализатора.

При этом обращаться к `self` можно после определения экземпляра.

```swift
struct Model {
    var a: Int
    var b: Int
    
    init(a: Int) {
        self.a = a
        self.b = 10
    }
    init(param1: Int, param2: Int) {
        self.b = param2 // Error: 'self' used before 'self.init' call or assignment to 'self'
        self.init(a: param1)
    }
}
```

Сначала необходимо проинициализировать все свойства и экземпляр. Исправим пример выше:

```swift
struct Model {
    var a: Int
    var b: Int
    
    init(a: Int) {
        self.a = a
        self.b = 10
    }
    init(param1: Int, param2: Int) {
        self.init(a: param1)
        self.b = param2
    }
}

var instance = Model(param1: 20, param2: 30)
print(instance.a)
print(instance.b)

// Output
// 20
// 30
```

Теперь инициализатор `init(param1:, param2:)` выполнит следующие инструкции:

- вызовет инициализатор `init(a:)` и передаст в качестве аргумента параметра `a` значение `param1` - `20`. Теперь свойства проинициализированы так: `a = 20`, `b = 10`;
- теперь можно обратиться к `self` и передать в свойство `b` значение `param2` - `30`. Теперь свойства проинициализированы так: `a = 20`, `b = 30`.

> Внимание. Если вы определите пользовательский инициализатор для типов значений, то вы больше не будете иметь доступа к дефолтному инициализатору (или почленному инициализатору, если это структура) для этого типа. Такое ограничение предотвращает ситуацию, в которой настройка важного дополнения в более сложном инициализаторе может быть пропущена при случайном использовании автоматического инициализатора.

Если необходимо, чтобы ваш пользовательский тип значения имел возможность быть инициализированным дефолтным инициализатором или почленным инициализатором, или вашим пользовательским инициализатором, то вам нужно написать свой пользовательский инициализатор в расширении вашего типа, чем как часть реализации типа значения.

```
struct Model {
    var a: Int
    var b: Int
}

extension Model {
    init(a: Int) {
        self.a = a
        self.b = 10
    }
    init(param1: Int, param2: Int) {
        self.init(a: param1)
        self.b = param2
    }
}
```

Теперь доступны такие инициализаторы:

- `init(a: Int, b: Int)` - поэлементный инициализатор;
- `init(param1: Int, param2: Int)` - назначенный инициализатор (пользовательский);
- `init(a: Int)` - назначенный инициализатор (пользовательский).

В качестве следующего примера реализуем три модели:

- первая - определяет координаты точки;
- вторая - определяет размеры;
- третья - определяет фигуру (прямоугольник), используя первые две модели.

```swift
struct Point {
    var x = 0.0, y = 0.0
}

struct Size {
    var width = 0.0, height = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()

    init() {}

    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }

    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```

Первые две структуры предоставляют значения по умолчанию - `0.0`. Соответственно, экземпляры этих структур будут проинициализированы с этими значениями по умолчанию.

Третья структура `Rect` позволяет создать экземпляр тремя способами.

Инициализатор `init()` структуры `Rect` -  функционально тот же самый, что и инициализатор по умолчанию (дефолтный), который получила бы структура, если бы не имела пользовательских инициализаторов. Инициализатор имеет пустое тело, отображенное парой пустых фигурных скобок `{}`, и не проводит никакой инициализации.

Вызывая такой инициализатор, мы получаем экземпляр `Rect`, который имеет инициализированные свойства `origin`, `size` значениями `Point(x: 0.0, y: 0.0)` и `Size(width: 0.0, height: 0.0)`, которые известны из определения свойств:

```swift
let basicRect = Rect()
//исходная точка Rect (0.0, 0.0) и его размер (0.0, 0.0)
```

Инициализатор `init(origin:size:)` структуры `Rect` -  функционально такой же, что и почленный инициализатор, который могла бы иметь структура `Rect`, если бы не имела пользовательских инициализаторов. Этот инициализатор просто присваивает значения аргументов `origin`, `size` соответствующим свойствам:

```swift
let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))
//исходная точка Rect (2.0, 2.0) и его размер (5.0, 5.0)
```

Инициализатор `init(center:size:)` структуры `Rect` немного более сложный. Он начинается с вычисления соответствующей исходной точки, основываясь на точке `center` и значении `size`. Только потом он вызывает (или делегирует) `init(origin:size: )` инициализатор, который хранит новую исходную точку и значения размеров соответствующих свойств:

```swift
let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))
//исходная точка centerRect’а равна (2.5, 2.5) и его размер (3.0, 3.0)
```

Инициализатор `init(center:size:)` мог бы присвоить новые значения `origin`, `size` соответствующим свойствам самостоятельно. Однако более удобно (т.к. более понятный из-за краткости) для инициализатора `init(center:size:)` воспользоваться преимуществом того, что существует другой инициализатор с абсолютно такой же функциональностью.

### Делегирование инициализатора для классовых типов. Отношения между инициализаторами

В вопросах отношений между инициализаторами Swift соблюдает следующие правила:

- Назначенный инициализатор подкласса должен вызвать назначенный инициализатор суперкласса;
- Вспомогательный инициализатор должен вызывать другой инициализатор из того же объектного типа (из того же класса);
- Вспомогательный инициализатор в конечном счете должен вызвать назначенный инициализатор того же объектного типа (из того же класса). Вспомогательный инициализатор может вызывать назначенный инициализатор через другой вспомогательный инициализатор.

На изображении ниже представлены эти правила.
    
![Отношения между инициализаторами](https://obodev.github.io/assets/images/initialization-relationship.png "Отношения между инициализаторами")

Здесь изображен суперкласс с одним назначенным и двумя вспомогательными инициализаторами. Один из вспомогательных инициализаторов вызывает другой, который, в свою очередь, вызывает назначенный. 

Также изображен подкласс, имеющий два собственных назначенных инициализатора и один вспомогательный.

Вызов любого инициализатора из изображенных должен в итоге вызывать назначенный инициализатор суперкласса (левый верхний блок).

Назначенный инициализатор не может вызывать другой назначенный инициализатор в пределах одного класса, то есть использование конструкции `self.init()` запрещено. Более детально можно узнать в разделе "Двухфазная инициализация классов" ниже.

Вот как можно просто это запомнить:

- Назначенные инициализаторы должны делегировать наверх;
- Вспомогательные инициализаторы должны делегировать по своему уровню (классу).

Из примера выше:

```swift
class Circle {
    var radius: Double
    var circumference: Double {
        2 * .pi * radius
    }
 
    init(radius: Double) {
        self.radius = radius
    }

    convenience init(circumference: Double) {
        self.init(radius: circumference / (.pi * 2))
    }
}
```

Вспомогательный инициализатор вызывает назначенный инициализатор из того же класса, с помощью `self.init`. Вспомогательный инициализатор *делегирует инициализацию* назначенному инициализатору.

> Примечание. Эти правила никак не относятся к тому, как пользователи ваших классов создают экземпляры каждого класса. Любой инициализатор из схемы выше может быть использован для создания полностью инициализированного экземпляра класса, которому он принадлежит. Правила влияют лишь на то, как вы будете писать реализацию класса.

Следующая схема показывает более сложную иерархию из четырех классов. Она показывает как назначенные инициализаторы работают в качестве точек прохождения инициализации класса, упрощая внутренние взаимоотношения среди цепочки классов:

![Отношения между инициализаторами (продвинутая версия)](https://obodev.github.io/assets/images/initialization-relationship-advanced.png "Отношения между инициализаторами (продвинутая версия)")

На схеме можно увидеть, что

- все вспомогательные инициализаторы в конечном счёте вызывают назначенные инициализаторы в пределах своего класса;
- все назначенные инициализаторы вызывают назначенный инициализатор в родительском классе;
- в конечном итоге вызывается назначенный инициализатор суперкласса (на схеме - в верхнем левом углу).

## Двухфазная инициализация классов

Инициализация класса в языке Swift является двухфазным процессом.

На первой фазе каждое свойство хранения получает начальное значение от класса, в котором оно представлено.

Как только первоначальные значения для свойств хранения были определены, начинается вторая фаза, и каждому классу предоставляется возможность изменить свои свойства еще до того как будет считаться, что созданный экземпляр можно использовать.

Использование двухфазного процесса инициализации делает инициализацию безопасной, в то же время обеспечивая полную гибкость классов в классовой иерархии. Двухфазная инициализация предотвращает доступ к значениям свойств до того, как они будут инициализированы и не допускает случайную установку значения свойства другим инициализатором.

Компилятор языка Swift проводит четыре полезные проверки безопасности для подтверждения того, что ваша двухфазная инициализация прошла без ошибок:

**Проверка 1**. Назначенный инициализатор должен убедиться в том, что все свойства представленные его классом инициализированы до того, как он делегирует наверх, в инициализатор суперкласса.

Память для объекта считается полностью инициализированной только для полностью инициализированного объекта, где все значения хранимых свойств известны. Для того чтобы удовлетворить этому правилу, назначенный инициализатор должен убедиться, что все его собственные свойства инициализированы до того, как будут переданы вверх по цепочке.

**Проверка 2**. Назначенный инициализатор должен делегировать суперклассу инициализатор до присваивания значений унаследованным свойствам. Если этого сделано не будет, то новое значение, которое присвоит назначенный инициализатор будет переписано суперклассом, как часть инициализации суперкласса.

**Проверка 3**. Вспомогательный инициализатор должен делегировать инициализацию другому инициализатору до того, как будут присвоены значения любым свойствам (включая свойства определенные тем же классом). Если этого сделано не будет, то новое значение, которое присваивает вспомогательный инициализатор, будет перезаписано его собственным назначенным инициализатором класса.

**Проверка 4**. Инициализатор не может вызывать методы экземпляра, читать значения любого свойства экземпляра или ссылаться на `self` как на значение до тех пор, пока не будет закончена первая фаза инициализации.

Экземпляр класса является не совсем корректным до тех пор, пока не закончится первая фаза. К свойствам можно получить доступ и можно вызывать методы только тогда, как стало известно, что экземпляр валиден (корректен) к концу первой фазы.

Теперь рассмотрим как проходит двухфазная инициализация, на основании четырех проверок, которые описаны выше:

**Фаза первая**

- Назначенный или вспомогательный инициализатор вызывается в классе.
- Память под новый экземпляр этого класса выделяется. Но она еще не инициализирована.
- Назначенный инициализатор для этого класса подтверждает, что все свойства, представленные этим классом, имеют значения. Память под эти свойства теперь инициализирована.
- Назначенный инициализатор передает инициализатору суперкласса, что пора проводить те же действия, только для его собственных свойств.
- Так продолжается по цепочке до самого верхнего суперкласса.
- После того как верхушка этой цепочки достигнута и последний класс в цепочке убедился в том, что все его свойства имеют значение, только тогда считается, что память для этого экземпляра полностью инициализирована. На этом первая фаза кончается.

**Фаза вторая**

- Двигаясь вниз по цепочке, каждый назначенный инициализатор в этой цепочке имеет такую возможность, как настраивать экземпляр. Теперь инициализаторы получают доступ к `self` и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д.
- И наконец, каждый вспомогательный инициализатор в цепочке имеет возможность настраивать экземпляр и работать с `self`.

Рассмотрим более подробно работу каждой фазы.

Вот как выглядит первая фаза для гипотетического подкласса и суперкласса:

![Первая фаза двухфазной инициализации](https://obodev.github.io/assets/images/initialization-stage-1.png "Первая фаза двухфазной инициализации")

В этом примере инициализация начинается с вызова вспомогательного инициализатора подкласса. Вспомогательный инициализатор пока не может изменять каких-либо свойств. Он делегирует назначенному инициализатору по тому же классу, где и он сам.

Назначенный инициализатор убеждается, что все свойства, подкласса имеют значения, как указано в **проверке 1**. После этого он вызывает назначенный инициализатор своего суперкласса для продолжения инициализации.

Назначенный инициализатор суперкласса проверяет наличие значений у всех свойств суперкласса. Далее нет продолжения цепочки наверх, к другому суперклассу, так что нет дальнейшей нужды в делегировании.

Сразу после того как все свойства суперкласса получают начальные значения, память считается полностью инициализированной и первая фаза завершается.

Вот как выглядит вторая фаза для гипотетического подкласса и суперкласса:

![Вторая фаза двухфазной инициализации](https://obodev.github.io/assets/images/initialization-stage-2.png "Вторая фаза двухфазной инициализации")

Назначенный инициализатор суперкласса только теперь получает возможность менять дальнейшие экземпляры (хотя и не обязан).

Как только назначенный инициализатор суперкласса заканчивает работу, получает возможность вносить изменения назначенный инициализатор подкласса (хотя он так же и не обязан это делать).

Наконец, как только заканчивает работу назначенный инициализатор подкласса, то возможность вносить изменения получает вспомогательный инициализатор, который изначально был вызван.

Таким образом, если рассмотреть весь процесс инициализации, то процесс в первой фазе идёт вверх (к назначенному инициализатору суперкласса), а потом, во второй фазе, спускается вниз (к изначально вызванному инициализатору).

## Наследование и переопределение инициализаторов

Подклассы в Swift не наследуют инициализаторов их суперклассов по умолчанию, в отличии от подклассов в Objective-C.

Инициализаторы суперкласса наследуются в определенных обстоятельствах, но только когда это безопасно и когда это имеет смысл делать. Далее это будет рассмотрено.

### Переопределение инициализаторов

Если необходимо, чтобы у вашего подкласса были один или более инициализаторов его суперклассов, вы можете сделать свою реализацию этих инициализаторов внутри подкласса - переопределить инициализаторы.

Когда определяется инициализатор подкласса, который совпадает с назначенным инициализатором суперкласса, то фактически переопределяется назначенный инициализатор. Таким образом необходимо писать модификатор `override` перед определением инициализатора подкласса. Это верно даже если переопределяется автоматически предоставляемый инициализатор, как описано в разделе "Встроенный инициализатор (Default Initializer)".

Так же как и переопределённые свойства, методы или индексы, присутствие модификатора `override` подсказывает Swift проверить то, что суперкласс имеет совпадающий назначенный инициализатор, который должен быть переписан, и проверить параметры вашего переопределяющего инициализатора, чтобы они были определены так как и предполагалось.

> Примечание. Всегда необходимо писать модификатор `override`, в случае когда переписывается назначенный инициализатор суперкласса, даже если ваша реализация инициализатора подкласса является вспомогательным инициализатором.

И наоборот, если определить инициализатор подкласса, который совпадает с вспомогательным инициализатором суперкласса, то этот вспомогательный инициализатор суперкласса никогда не сможет быть вызван напрямую подклассом, в соответствии с правилами указанными выше. Таким образом ваш подкласс не проводит переопределение вспомогательного инициализатора суперкласса.

Как итог, не нужно указывать модификатор `override`, когда указывается реализация, которая совпадает с реализацией вспомогательного инициализатора суперкласса.

Пример ниже определяет базовый класс `Vehicle`. Это базовый класс объявляет свойства `numberOfWheels` со значением `0` типа `Int`. Свойство `numberOfWheels` используется для вычисляемого свойства `description`, для создания описания характеристик транспортного средства типа `String`:

```swift
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) колес(о)"
    }
}
```

Класс `Vehicle` предоставляет значение по умолчанию для его единственного свойства, и не имеет никаких собственных пользовательских инициализаторов. В результате он автоматически получает дефолтный инициализатор (встроенный инициализатор по умолчанию). Дефолтный инициализатор (когда доступен) всегда является назначенным инициализатором для класса и может быть использован для создания нового экземпляра класса `Vehicle` с `numberOfWheels` равным `0`:

```swift
let vehicle = Vehicle()
print("Транспортное средство \(vehicle.description)")

// Output
// Транспортное средство 0 колес(о)
```

Далее определим подкласс `Bicycle` суперкласса `Vehicle`:

```swift
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
```

Подкласс `Bicycle` определяет пользовательский назначенный инициализатор `init()`. Назначенный инициализатор совпадает с назначенным инициализатором из суперкласса `Vehicle` и, таким образом, версия этого инициализатора класса `Bicycle` отмечена модификатором `override`.

Инициализатор `init()` для `Bicycle` начинается с вызова `super.init()`, который в свою очередь вызывает дефолтный инициализатор для суперкласса `Vehicle` класса `Bicycle`. Он проверяет, что унаследованное свойство `numberOfWheels` инициализировано в `Vehicle`, после чего у `Bicycle` появляется возможность его модифицировать. После вызова `super.init()` начальное значение `numberOfWheels` заменяется значением `2`.

Если указать значение свойству `numberOfWheels` до того как будет вызван инициализатор суперкласса, то получим ошибку. 

```swift
class Bicycle: Vehicle {
    override init() {
        numberOfWheels = 2 // Error: 'self' used in property access 'numberOfWheels' before 'super.init' call
        super.init()
    }
}
```

Нельзя обратиться к свойству `numberOfWheels` до того, как оно будет проинициализировано в суперклассе `Vehicle`.

Теперь если создать экземпляр `Bicycle`, то можно вызвать его унаследованное вычисляемое свойство `description`, для того, чтобы посмотреть как обновилось свойство `numberOfWheels`:

```swift
let bicycle = Bicycle()
print("Велосипед: \(bicycle.description)")

// Output
// Велосипед: 2 колес(а)
```

> Примечание. Подклассы могут менять унаследованные переменные свойства в процессе инициализации, но нельзя менять неизменяемые унаследованные свойства.

Теперь определим ещё один подкласс `Car` суперкласса `Vehicle`:

```swift
class Car: Vehicle {
    var numberOfDoors: Int
    override var description: String {
        return "\(numberOfWheels) колес(о), \(numberOfDoors) дверей"
    }
    
    override init() {
        super.init() // Error: Property 'self.numberOfDoors' not initialized at super.init call
        numberOfWheels = 4
        numberOfDoors = 4
    }
}
```

В подклассе `Car` было добавлено новое свойство `numberOfDoors` и кроме инициализатора переопределено свойство `description`.

В данном определении класса `Car` была получена ошибка, которая указывает, что в инициализаторе суперкласса отсутствует инициализация нового свойства `numberOfDoors`. То есть возникла ошибка на первой фазе: назначенный инициализатор для класса `Car` не может подтвердить, что все свойства, представленные этим классом, имеют значения.

Чтоб устранить эту ошибку необходимо сначала для свойства указать значение:

```swift
class Car: Vehicle {
    var numberOfDoors: Int
    override var description: String {
        return "\(numberOfWheels) колес(о), \(numberOfDoors) дверей"
    }
    
    override init() {
        numberOfDoors = 4
        super.init()
        numberOfWheels = 4
    }
}
```

Теперь у свойства `numberOfDoors` есть значение `4`. После этого происходит вызов инициализатора суперкласса `super.init()`, который инициализирует свойство `numberOfWheels` со значением `0`. И затем происходит окончательная настройка экземпляра `Car`: свойству `numberOfWheels` присваивается значение `4`.

Создав экземпляр `Car `, можно посмотреть как обновилось свойство `numberOfWheels`. Также появилось свойство `numberOfDoors`. Для этого можно вызвать его переопределённое унаследованное вычисляемое свойство `description`.

```swift
let auto = Car()
print("Автомобиль: \(auto.description)")

// Output
// Автомобиль: 4 колес(о), 4 дверей
```

### Автоматическое наследование инициализатора

Как было сказано ранее, подклассы не наследуют инициализаторы суперкласса по умолчанию. Однако инициализаторы суперкласса автоматически наследуются, если есть для того специальные условия. На практике это значит, что во многих случаях вам не нужно писать переопределения инициализатора, так как он может наследовать инициализаторы суперкласса с минимальными усилиями, но только когда это безопасно.

Классы, могут наследоваться от других классов. Это значит, что у классов есть дополнительная ответственность за проверку наличия корректных значений у каждого унаследованного свойства хранения класса.

Наследование инициализаторов отличается от наследования обычных методов суперкласса. Допуская, что вы предоставляете значения по умолчанию любому новому свойству, представленному в подклассе, то применяются два правила:

- **Правило 1**. Если ваш подкласс не определяет ни одного назначенного инициализатора, он автоматически наследует все назначенные инициализаторы суперкласса. Если подкласс имеет собственный назначенный инициализатор, то инициализаторы родительского класса не наследуются.

- **Правило 2**. Если у вашего класса есть реализация всех назначенных инициализаторов его суперкласса, либо они были унаследованы как по правилу 1 или же предоставлены как часть пользовательской реализации определения подкласса, то тогда этот подкласс автоматически наследует все вспомогательные инициализаторы суперкласса.

Эти правила применимы даже если ваш подкласс позже добавляет вспомогательные инициализаторы.

> Примечание. Подкласс может реализовать назначенный инициализатор суперкласса как вспомогательный инициализатор подкласса в качестве части удовлетворяющей правилу 2.

### Примеры работы инициализаторов в классах и подклассах

Определим класс `Circle` и его подкласс `Cylinder`:

```swift
class Circle {
    var radius: Double
    var circumference: Double {
        2 * .pi * radius
    }
 
    init(radius: Double) {
        self.radius = radius
    }
 
    convenience init(circumference: Double) {
        self.init(radius: circumference / (.pi * 2))
    }
}
```

Основной класс называется `Circle`. У него есть два свойства:

- хранимое свойство с именем `radius` и типом `String`;
- вычисляемое свойство с именем `circumference` и типом `Double`;

и два инициализатора для создания экземпляром класса `Circle`.

Схема показывает цепочку работы инициализаторов в классе `Circle`:

`convenience init(circumference:)` -> `init(radius:)`

Классы по умолчанию не имеют почленного инициализатора, так что класс `Circle` предоставляет назначенный инициализатор, который принимает единственный аргумент `radius`. Этот инициализатор может быть использован для создания экземпляра `Circle` со специфичным радиусом:

```swift
let circleOne = Circle(radius: 100)
print("Radius: \(circleOne.radius), Circumference: \(circleOne.circumference)")

// Output
// Radius: 100.0, Circumference: 628.3185307179587
```

Инициализатор `init(radius: String)` из класса `Circle`, представлен в виде назначенного инициализатора, потому что он проверяет, что все хранимые свойства нового экземпляра `Circle` полностью инициализированы. Класс `Circle` не имеет суперкласса, так что инициализатор `init(radius: String)` не имеет вызова `super.init()` для завершения своей инициализации.

Класс `Circle` так же обеспечивает вспомогательный инициализатор `init(circumference:)` с аргументом `circumference`. Инициализатор `init(circumference:)` предоставляет имя плейсхолдера для новой окружности и делегирует к параметру `radius` инициализатора `init(radius: String)`, давая ему значение `circumference / (.pi * 2)`:

```swift
let circleTwo = Circle(circumference: 950)
print("Radius: \(circleTwo.radius), Circumference: \(circleTwo.circumference)")

// Output
// Radius: 151.19719593730056, Circumference: 949.9999999999999
```

В этом примере в вспомогательный инициализатор передал в назначенный инициализатор значение параметра `radius`. Назначенный инициализатор проинициализировал свойство `radius`. При обращению к экземпляру `circleTwo` значение свойства `circumference` было расчитанно исходя из значения свойства `radius`.

Далее объявим класс `Cylinder` который наследует класс `Circle`. Класс `Cylinder` наследует свойства и методы из класса `Circle`: `radius` и `circumference`.

```swift
class Cylinder: Circle {
    var height: Double
    var volume: Double {
        .pi * radius * radius * height
    }
 
    init(radius: Double, height: Double) {
        self.height = height
        super.init(radius: radius)
    }
}
```

Также у класса `Cylinder` есть хранимое свойство `height`, а также вычисляемое свойство `volume` типа `Double`.

Класс `Cylinder` определяет один назначенный инициализатор, который принимает параметры `radius` и `height`. Параметр `height` назначается свойству `height` через `self.height`, а параметр `radius` назначается свойству `radius` через вызов инициализатора родительского класса (суперкласса) - `super.init()`.

Инициализатор суперкласса `init(radius:)` вызывается, чтоб сохранить цепочку инициализаторов без изменений.

Обратите внимание на вызов инициализатора суперкласса. Он вызывается после определения значений хранимых свойств дочернего класса - `self.height = height`. Это требование первой фазы Двухфазной инициализации, а именно: 

- Назначенный инициализатор для класса подтверждает, что все свойства, представленные этим классом, имеют значения; Память под эти свойства теперь инициализирована; 
- Назначенный инициализатор передает инициализатору суперкласса, что пора проводить те же действия, только для его собственных свойств.

Так как в классе `Cylinder` указан назначенный инициализатор, то, согласно `Правилу 1` из раздела "Автоматическое наследование инициализатора", класс `Cylinder` не наследует инициализаторы родительского класса `Circle`.

Схема показывает цепочку работы инициализаторов в классе `Cylinder`:

`class Cylinder` `init(radius:, height:)` -> `class Circle ` `init(radius:)`

Создадим экземпляр класса `Cylinder`:

```swift
let cylinderOne = Cylinder(radius: 150, height: 100)
print("Radius: \(cylinderOne.radius), Circumference: \(cylinderOne.circumference), Height: \(cylinderOne.height)")

// Output
// Radius: 150.0, Circumference: 942.4777960769379, Height: 100.0
```

Для того, чтоб унаследовать инициализаторы родительского класса `Circle`, достаточно в классе `Cylinder` переопределить назначенный инициализатор из родительского класса. Например

```swift
class Cylinder: Circle {
    var height: Double = 10
    var volume: Double {
        .pi * radius * radius * height
    }
 
    init(radius: Double, height: Double) {
        self.height = height
        super.init(radius: radius)
    }
    override init(radius: Double) {
        self.height = 1
        super.init(radius: radius)
    }
}
```

Далее можно создать экземпляры класса `Cylinder` с помощью унаследованных инициализаторов класса `Circle`:

```swift 
let cylinderOne = Cylinder(radius: 150, height: 100)
print("Radius: \(cylinderOne.radius), Circumference: \(cylinderOne.circumference), Height: \(cylinderOne.height)")

// Output
// Radius: 150.0, Circumference: 942.4777960769379, Height: 100.0

let cylinderTwo = Cylinder(radius: 200)
print("Radius: \(cylinderTwo.radius), Circumference: \(cylinderTwo.circumference), Height: \(cylinderTwo.height)")

// Output
// Radius: 200.0, Circumference: 1256.6370614359173, Height: 1.0

let cylinderThree = Cylinder(circumference: 500)
print("Radius: \(cylinderThree.radius), Circumference: \(cylinderThree.circumference), Height: \(cylinderThree.height)")

// Output
// Radius: 79.57747154594767, Circumference: 500.0, Height: 1.0
```

- объект `cylinderOne` инициализирован с помощью назначенного инициализатора класса `Cylinder`;
- объект `cylinderTwo` инициализирован с помощью переопределённого назначенного инициализатора класса `Circle`;
- объект `cylinderThree` инициализирован с помощью унаследованного вспомогательного инициализатора от класса `Circle`.

Унаследованный вспомогательный инициализатора от класса `Circle` делегирует инициализацию в назначенный инициализатор `init(radius:)` класса `Cylinder`, а не `Circle`. Именно поэтому свойство `height` было проинициализировано со значением `1`.

## Проваливающийся инициализатор (Failable Initializer)

В некоторых ситуациях бывает необходимо определить объектный тип, создание экземпляра которого может закончиться неудачей, вызванной некорректным набором внешних параметров, отсутствием какого-либо внешнего ресурса или иным обстоятельством, которое может не позволить завершить инициализацию успешно. Для этой цели служат проваливающиеся (failable) инициализаторы. Они способны возвращать `nil` при попытке создания экземпляра. И это их основное предназначение.

**Проваливающийся инициализатор (failable initializer)** — это инициализатор, который может выполнить инициализацию или может вернуть `nil` (провалиться). Это своего рода инициализатор для опционалов.

Рассмотрим следующий код:

```swift
let age = Int("42")
print(age)

// Output
// Optional(42)
 
let year = Int("two thousand and twenty")
print(year)

// Output
// nil
```

Инициализатор `Int(...)` — проваливающийся, failable. Это означает, что он может вернуть `nil`, если вы предоставите неверные входные параметры.

В первом примере мы предоставляем строку `"42"`, которая может быть успешно преобразована в целочисленное значение `42`. Во втором примере мы предоставляем текстовую строку, которая не может быть преобразована в целочисленное значение, поэтому `year` будет равен `nil`. Обратите внимание, что в обоих случаях тип возвращаемого значения — `Int?`.

Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления. Вы можете написать проваливающийся инициализатор поместив вопросительный знак после ключевого слова `init` - `init?()`.

Синтаксис проваливающегося инициализатора:

```swift
init?() {
    // code
}
```

Для создания проваливающегося инициализатора служит ключевое слово `init?` (со знаком вопроса), который говорит о том, что возвращаемый экземпляр будет опционалом или его не будет вовсе.

В теле инициализатора должно присутствовать выражение `return nil`.

Можно объявить (создать) собственный failable-инициализатор с помощью конструкции `init?()`:

```swift
init?(value: ...) {
    guard условие else {
        return nil
    }
    ···
}
```

В приведенном выше примере кода мы возвращаем `nil`, если наше условие возвращает `false`.

> Заметка. Нельзя определить проваливающийся инициализатор и обычные инициализаторы с одними и теми же именами и типами параметров.

Проваливающийся инициализатор создает опциональное значение типа, который он инициализирует. Необходимо указать `return nil` внутри проваливающегося инициализатора для индикации точки, где инициализация может провалиться.

> Заметка. Инициализаторы не возвращают значений. Их роль заключается в том, что они проверяют, что `self` полностью и корректно инициализирован, до того, как инициализация закончится. Несмотря на то, что указывается `return nil` для указания неудачи инициализации, не нужно указывать слово `return` в случае, если инициализация прошла успешно.

Проваливающийся инициализатор указывается помещая вопросительный знак (`?`) после ключевого слова `init` и возвращая `nil`, если что-то пойдет не так. Например,

```swift
class File {

    var folder: String

    // failable initializer
    init?(folder: String) {

        // check if empty
        if folder.isEmpty {
            print("Folder Not Found") // 1st output
            return nil
        }
        self.folder = folder
    }
}

// create folder1 object
var file  = File(folder: "")
if (file != nil) {
    print("File Found Successfully")
} else {
    print("Error Finding File") // 2nd output
}

// Output
// Folder Not Found
// Error Finding File
```

В приведенном выше примере был создан проваливающийся инициализатор `init?()` с параметром с именем `folder`.

И использовались оператор `if` и свойство `isEmpty`.

```swift
if (folder.isEmpty) { return nil }
```

чтобы проверить, пустой ли параметр `folder`, и возвращает `nil`, если он пустой.

Для объекта `folder1` передали пустую строку `""`, которая вызывает сбой инициализации, поэтому оператор `if` внутри него выполняется первым, а затем возвращает `nil`.

И, наконец, выполняется код внутри блока `else`.

Рассмотрим ещё один пример реализации проваливающегося инициализатора. Создадим класс, описывающий сущность «прямоугольник». При создании экземпляра данного класса необходимо контролировать значения передаваемых параметров (высота и ширина), чтобы они обязательно были больше нуля. При этом в случае некорректных значений параметров программа не должна завершаться с ошибкой.

Для решения данной задачи используем проваливающийся инициализатор.

```swift
class Rectangle {
    var height: Int

    var weight: Int

    init?(height h: Int, weight w: Int) {
        self.height = h
        self.weight = w

        if !(h > 0 && w > 0) {
            return nil
        }

    }

}

var rectangle = Rectangle(height: 56, weight: -32) // возвращает nil
```

Инициализатор принимает и проверяет значения двух параметров. Если хотя бы одно из них меньше или равно нулю, то возвращается `nil`. Обратите внимание на то, что, прежде чем вернуть `nil`, инициализатор устанавливает значения всех хранимых свойств.

> Внимание. В классах проваливающийся инициализатор может вернуть `nil` только после установки значений всех хранимых свойств. В случае структур данное ограничение отсутствует.

### Проваливающийся инициализатор для перечислений

Можно использовать проваливающийся инициализатор для выбора подходящего члена перечисления основываясь на одном или более параметров. Инициализатор может провалиться, если предоставленные параметры не будут соответствовать подходящему члену перечисления.

В следующем примере объявляется перечисление `TemperatureUnit`, которое содержит три члена. Проваливающийся инициализатор используется для того, чтобы вернуть член перечисления, соответствующий переданному параметру, или `nil`, если значение параметра некорректно.

```swift
enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit

    init?(symbol: Character) {

        switch symbol {
            case "K":
                self = .Kelvin
            case "C":
                self = .Celsius
            case "F":
                self = .Fahrenheit
            default:
                return nil
        }

    }

}

let fahrenheitUnit = TemperatureUnit(symbol: "F")
```

При создании экземпляра перечисления в качестве входного параметра `symbol` передается значение. На основе переданного значения возвращается соответствующий член перечисления.

У перечислений, члены которых имеют значения (Raw Value), есть встроенный проваливающийся инициализатор `init?(rawValue:)`. Его можно использовать без определения в коде.

```swift
enum TemperatureUnit: Character {
    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")

fahrenheitUnit!.hashValue
```

Члены перечисления `TemperatureUnit` имеют значения типа `Character`. В этом случае вы можете вызвать встроенный проваливающийся инициализатор, который вернет член перечисления, соответствующий переданному значению.

Пример ниже определяет перечисление `DayOfWeek` с несколькими возможными вариантами (`monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `sunday`).

Проваливающийся инициализатор используется для того, чтобы найти подходящий член перечисления для значения типа `String`, которое представляет день недели:

```swift
enum DayOfWeek: Int {
    case monday = 1, tuesday, wednesday, thursday, friday, saturday, sunday
    init?(_ val: String) {
        switch val {
        case "Понедельник":
            self = .monday
        case "Вторник":
            self = .tuesday
        case "Среда":
            self = .wednesday
        case "Четверг":
            self = .thursday
        case "Пятница":
            self = .friday
        case "Суббота":
            self = .saturday
        case "Воскресенье":
            self = .sunday
        default:
            return nil
        }
    }
}

var monday = DayOfWeek("Понедельник")
print(monday!.rawValue)

// Output
// 1
```

Здесь переменной `monday` присваивается значение `.monday` перечисления `DayOfWeek`. Если при инициализации указать неверное значение, то инициализатор вернет `nil`.

### Проваливающийся инициализатор для перечислений с начальными значениями

Перечисления с начальными значениями по умолчанию получают проваливающийся инициализатор `init?(rawValue:)`, который принимает параметр `rawValue` подходящего типа и выбирает соответствующий член перечисления, если он находит подходящий, или срабатывает сбой инициализации, если существующее значение не находит совпадения среди членов перечисления.

Возьмём пример выше и создадим два экземпляра:

```swift
var dayFirst = DayOfWeek(rawValue: 1)
var dayUnknown = DayOfWeek(rawValue: 9)

func checkDay(_ day: DayOfWeek?) {
    if day != nil {
        print(day!)
    } else {
        print("Unknown day!")
    }
}

checkDay(dayFirst)

// Output
// monday

checkDay(dayUnknown)

// Output
// Unknown day!
```

- экземпляр `dayFirst` проинициализирован со значением `monday`;
- экземпляр `dayUnknown` проинициализирован со значением `nil`.

### Делегирование проваливающегося инициализатора

Проваливающийся инициализатор класса, структуры, перечисления может быть делегирован к другому проваливающемуся инициализатору из того же класса, структуры, перечисления. Аналогично проваливающийся инициализатор подкласса может быть делегирован наверх в проваливающийся инициализатор суперкласса.

В любом случае, если происходит делегирование другому инициализатору, который проваливает инициализацию то и весь процесс инициализации проваливается немедленно за ним, и далее никакой код инициализации уже не исполняется.

В примере определим подкласс `CartItem` класса `Product`. `CartItem` создает модель элемента в корзине онлайн заказа. `CartItem` представляет свойство хранения `quantity` и проверяет, чтобы это свойство всегда имело значение не менее `1`:

```swift
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
 
class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
```

Проваливающийся инициализатор для `CartItem` начинается с того, что получает значение `quantity` равное `1` или более. Если значение `quantity` некорректное, то вся инициализация проваливается и код дальше не исполняется. Так же проваливающийся инициализатор `Product` проверяет значение свойства `name`, и если оно равно пустой строке, то инициализация немедленно прекращается.

Если же создать экземпляр `CartItem` со свойством `name` не равным пустой строке и свойство `quantity` равному `1` или более, то инициализация проходит успешно:

```swift
if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}

// Output
// Item: sock, quantity: 2
```

Если попытается создать экземпляр `CartItem` со свойством `quantity` со значением `0`, то инициализация провалится:

```swift
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Невозможно инициализировать ноль футболок")
}

// Output
// Невозможно инициализировать ноль футболок
```

Аналогично, если попытаться создать экземпляр `CartItem` со свойством `name` равным пустой строке, то инициализатор суперкласса `Product` вызовет неудачу в инициализации:

```swift
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Невозможно инициализировать товар без имени")
}

// Output
// Невозможно инициализировать товар без имени
```

> Заметка. Проваливающийся инициализатор может также делегировать к непроваливающимуся инициализатору. Используя такой подход, вам следует добавить потенциальное состояние провала в существующий процесс инициализации, который в противном случае не провалится.

### Переопределение проваливающегося инициализатора

Можно переопределить проваливающийся инициализатор суперкласса в подклассе, так же как любой другой инициализатор. Или можно переопределить проваливающий инициализатор суперкласса непроваливающимся инициализатором подкласса. Это позволяет определить подкласс, для которого инициализация не может провалиться, даже когда инициализация суперкласса позволяет это сделать.

Если переопределяете проваливающийся инициализатор суперкласса не проваливающимся инициализатором подкласса, то единственным способом делегировать в инициализатор суперкласса - принудительное извлечение результата из проваливающего инициализатора суперкласса.

Назначенный инициализатор в подклассе может переопределить проваливающийся инициализатор суперкласса, а проваливающийся инициализатор может вызывать назначенный инициализатор того же класса.

> Важно. Можно переопределить проваливающийся инициализатор непроваливающимся инициализатором, но не наоборот.

Не забывайте, что в случае использования проваливающегося инициализатора возвращается опционал. Поэтому прежде чем работать с экземпляром, необходимо выполнить извлечение опционального значения.

Пример ниже определяет класс `Document`. Этот класс моделирует документ, который может быть инициализирован свойством `name`, которое может иметь значение, отличное от пустого или `nil`, но никак не пустую строку:

```swift
class Document {
    var name: String?

    init() {}

    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
```

- `init() {}` - этот инициализатор создает документ со значением `nil` свойства `name`;
- `init?(name: String) {...}` - этот инициализатор создает документ с *не пустым* свойством `name`.

`AutomaticallyNamedDocument` является подклассом класса `Document`, который переопределяет оба назначенных инициализатора, представленных в `Document`. Это переопределение гарантирует, что экземпляр `AutomaticallyNamedDocument` будет иметь исходное значение `"[Untitled]"` свойства `name`, если экземпляр создан без имени или если пустая строка передана в инициализатор `init(name: )`:

```swift
class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
```

`AutomaticallyNamedDocument` переопределяет проваливающийся инициализатор `init?(name: )` суперкласса непроваливающимся инициализатором `init(name: )`.

Из-за того, что `AutomaticallyNamedDocument` справляется с пустой строкой иначе, чем его суперкласс, его инициализатор не обязательно должен провалиться, таким образом *он предоставляет непроваливающуюся версию инициализатора вместо проваливающейся*.

Можно использовать принудительное извлечение внутри инициализатора для вызова проваливающегося инициализатора из суперкласса, в качестве части реализации непроваливающегося инициализатора подкласса. Например, подкласс `UntitledDocument` класса `Document` всегда имеет значение `"[Untitled]"` свойства `name`, и он использует проваливающийся `init(name: )` из суперкласса во время инициализации.

```swift
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}
```

В этом случае инициализатор суперкласса `init(name: )` каждый раз будет вызывать ошибку исполнения, если в него будет передана пустая строка.

Однако, так как этот инициализатор теперь имеет строковую константу, то этот инициализатор больше не провалится, то есть ошибки исполнения больше не будет.

### Проваливающийся инициализатор `init!`

Обычно проваливающийся инициализатор, который создает опциональный экземпляр соответствующего типа определяется путем размещения знака вопроса после ключевого слова `init` (`init?`).

В качестве альтернативы, можно определить проваливающийся инициализатор, который создает экземпляр неявно извлекаемого опционала соответствующего типа. Сделать это можно, если вместо вопросительного знака поставить восклицательный знак после ключевого слова `init` (`init!`).

`init!` возвращает неявно извлеченный экземпляр объектного типа, поскольку для работы с ним не требуется дополнительно извлекать опциональное значение. При этом все еще может возвращаться `nil`.

Можно делегировать от `init?` в `init!` и наоборот. Так же можно переопределить `init?` с помощью `init!` и наоборот. Так же можно делегировать от `init` в `init!`, хотя, делая таким образом, мы заставим сработать утверждение, если `init!` провалит инициализацию.

## Обязательный инициализатор (Required Initializer)

**Обязательный инициализатор (Required Initializer)** — это инициализатор, который обязательно должен быть определён во всех подклассах данного класса.

Необходимо указать модификатор `required` перед определением инициализатора класса, если необходимо, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор.

Синтаксис обязательного инициализатора:

```swift
class SomeClass {
    required init() {
        //пишем тут реализацию инициализатора
    }
}
```

Также нужно писать модификатор `required` перед каждой реализацией требуемого инициализатора класса для индикации того, что последующий подкласс так же должен унаследовать этот инициализатор по цепочке.

```swift
class SomeSubclass: SomeClass {
    required init() {
        //пишем тут реализацию инициализатора подкласса
    }
}
```

Интересно, что ключевое слово `required` подразумевает, что реализация инициализатора подкласса фактически переопределена. Модификатор `override` для функции `init()` не требуется.

> Заметка. Не нужно обеспечивать явную реализацию требуемого инициализатора, если можно удовлетворить требование унаследованным инициализатором.

Пример

```swift
class Vehicle {
    var engine: String
    required init() {
        engine = Diesel
    }
}
```

Если необходимо создать подкласс `Car`, нужно будет также реализовать вышеупомянутый инициализатор `init()`:

```swift
class Car: Vehicle {
    required init() {
        engine = Benzin
    }
}
```

## Начальное значение свойства в виде функции или замыкания

Если начальное значение свойства требует какой-то настройки или структуризации, то можно использовать замыкание или глобальную функцию, которая будет предоставлять значение для этого свойства. Как только создается новый экземпляр, вызывается функция или замыкание, которая возвращает значение, которое присваивается в качестве начального значения свойства.

Эти виды замыканий или функций обычно создают временное значение того же типа, что и свойство, используя эту величину для отображения желаемого начального состояния, затем возвращают ее в качестве начального значения свойства.

С данным видом инициализации свойства можно было ознакомится при изучении статьи "Переменные и константы" (см. ссылки внизу).
 
Ниже приведена схема того, как замыкание может предоставлять начальное значение свойству:

```swift
class SomeClass {
    let someProperty: SomeType = {
        let someValue: SomeType = ...
        // code
        return someValue
    }()
}
```

Внутри замыкания у свойства `someProperty` создаётся переменная (константа) `someValue` с тем же типом данных `SomeType`, что и свойство `someProperty`. затем выполняется дополнительный код, который влияет на `someValue`. В конце - возвращается `someValue`.

Переменная (константа) `someValue` является временной и возвращается в качестве возвращаемого значения свойству `someProperty` замыканием, как только замыкание выполнится.

Обратите внимание, что после закрывающей фигурной скобки замыкания идут пустая пара круглых скобок (`()`). Это означает, что нужно исполнить это замыкание немедленно. Если пропустите эти скобки, то в этом случае свойству `someProperty` будет присвоено само значение замыкания, а не возвращаете значения замыкания.

> Заметка. Если используете замыкание для инициализации свойства, помните, что **остальная часть экземпляра еще не инициализирована**, на тот момент когда исполняется замыкание. Это значит, что нельзя получить доступ к значениям других свойств из вашего замыкания, даже если эти свойства имеют начальное значение. 
>
> Вы так же не можете использовать неявное свойство `self` и не можете вызвать какой-либо метод вашего экземпляра.

Данный способ указания начального значения свойства очень часто используется в разработке мобильных приложений.

---

## Какие проблемы могут возникнуть с инициализаторами?

Обсудим некоторые проблемы, с которыми вы можете столкнуться при работе с инициализаторами.

### Необходимость вызывать назначенный инициализатор суперкласса

При создании подклассов инициализаторы должны вызывать назначенный инициализатор суперкласса.

Рассмотрим классы `Circle` и `Cylinder`, которые создали ранее. Если добавим новый инициализатор в класс `Cylinder`, он должен вызвать назначенный инициализатор суперкласса `Circle`:

```swift
class Cylinder: Circle {
    ···
    init(volume: Double) {
        ···
        super.init(radius: ...)
    }    
}
```

`init(radius:)` на самом деле является назначенным инициализатором суперкласса `Circle`. Обязательно вызывайте назначенный инициализатор суперкласса.

### В классе нет инициализаторов

Смысл этой ошибки прост: используемый вами класс не имеет инициализаторов. Обычно это означает 2 вещи:

- Вы не задали свойств класса значения по умолчанию, что означает, что они не были проинициализированы.
- Вы не добавили инициализатор `init()`.

```swift
class Car {
    var name: String
}
```

Приведенное выше свойство name класса `Car` не имеет значения по умолчанию, а класс не имеет инициализаторов. Вы можете либо предоставить значение по умолчанию, а затем использовать сгенерированный инициализатор по умолчанию, либо написать функцию `init()` самостоятельно.

### Свойство не инициализировано при вызове `super.init`

Одно из правил работы с инициализаторами заключается в том, что назначенный инициализатор должен инициализировать каждое из своих свойств перед вызовом `super.init()`.

Поскольку инициализатору суперкласса нельзя доверять для инициализации свойства подкласса, подкласс должен вначале убедиться, что инициализировал все свои свойства перед делегированием инициализации суперклассу.

---

# Деинициализация

Деинициализация — это процесс удаления экземпляров класса, когда они больше не нужны. Это освобождает место в памяти системы, занимаемое экземплярами. 

**Деинициализатор (деструктор)** - это специальный метод, который автоматически вызывается во время уничтожения экземпляра класса. Деинициализаторы доступны только для классовых типов и не доступны для структур.

Определения класса могут иметь максимум один деинициализатор на один класс. Деинициализатор не принимает ни одного параметра и пишется без круглых скобок:

Для создания деинициализатора используется ключевое слово `deinit`, после которого в фигурных скобках указывается тело деинициализатора.

Синтаксис деинициализатора

```swift
deinit {
    // code deinitialization
    ... 
}
```

С помощью деинициализатора вы можете, например, освободить используемые экземпляром ресурсы, вывести на консоль журнал или выполнить любые другие действия.

## Как работает деинициализация

Swift автоматически освобождает экземпляры, что освобождает память в свою очередь, когда они больше не нужны. Swift берет на себя управление памятью экземпляров через ARC (automatic reference counting, Автоматический подсчёт ссылок). Чаще всего не нужно вручную чистить память, когда экземпляры освобождаются. Однако, когда происходит работа с вашими собственными ресурсами, возможно, вам понадобится проводить дополнительную чистку.

К примеру, если вы создаете свой класс для открытия файла и записи в него какой-то информации, а потом его закрываете, то вам понадобится закрыть файл до того как вы освободите экземпляр класса.

Деинициализаторы вызываются автоматически прямо перед тем как освобождается экземпляр. У вас нет возможности вызывать деинициализатор самостоятельно.

Деинициализаторы суперкласса наследуются их подклассами и деинициализаторы суперкласса вызываются автоматически в конце реализации деинициализатора подкласса. Деинициализаторы суперклассов всегда вызываются, даже если подкласс не имеет своего деинициализатора.

Так как экземпляр не освобождается до тех пор пока не будет вызван деинициализатор, то деинициализатор может получить доступ ко всем свойствам экземпляра, который он вызывает, и может изменить свое поведение, основываясь на этих свойствах (например, имя файла, который должен быть закрыт).

Например,

```swift
// declare a class
class Race {
    var laps: Int

    // define initializer
    init() {
        laps = 5
        print("Race Completed")
        print("Total laps:", laps)
    }

    // define deinitializer
    deinit {
        print("Memory Deallocated")
    }
}

// create an instance
var result: Race? = Race()

// deallocate object
result = nil

// Output
// Race Completed
// Total laps: 5
// Memory Deallocated
```

Здесь `deinit` является деинициализатором класса `Race`.

В приведенном выше примере 

1. Создали деинициализатор внутри класса `Race`.

```swift
deinit {
    print("Memory Deallocated")
}
```

2. Затем создали экземпляр класса `Race` и присвоили его переменной типа `Race` с именем `result`.

```swift
// create an instance
var result: Race? = Race()
```

Здесь, `Race?` указывает, что результат является необязательным (опциональным), поэтому он может хранить два типа значений: 

- значения типа `Race`.
- значение `nil`. 

3. Наконец, присваиваем `nil` переменной `result`:

```swift
// deallocate instance
result = nil
```

Это освобождает экземпляр. Деинициализатор вызывается автоматически прямо перед освобождением экземпляра класса. И оператор внутри него выполняется.

> Примечание:
>
> - В Swift мы используем деинициализаторы только тогда, когда хотим вручную освободить экземпляры. В противном случае Swift автоматически выполняет освобождение.
> - Деинициализаторы можно использовать только с классами, а не со структурами.
> - Каждый класс может иметь только один деинициализатор.

Ещё пример

Для создания простой игры в этом примере определяются два новых типа `Bank` и `Player`. Класс `Bank` управляет наличностью, которой не может быть больше `10000` монет в обороте. В игре может быть только один `Bank`, так что `Bank` реализован в качестве класса со свойствами типа и методами хранения и управления текущим состоянием:

```swift
class Bank {
    static var coinsInBank = 10_000
    static func distribute(coins numberOfCoinsRequested: Int) -> Int {
        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receive(coins: Int) {
        coinsInBank += coins
    }
}
```

`Bank` следит за текущим количеством монет, которые у него есть в свойстве `coinsInBank`.

Так же он предоставляет два метода `distribute(coins:)`, `receive(coins:)` для обработки событий получения монет и их распределения.

- Метод `distribute(coins:)` проверяет достаточность количества монет в банке перед их дистрибуцией. Если в банке недостаточно монет, то `Bank` возвращает меньшее число, чем было запрошено (и возвращает ноль, если монет в банке не осталось). Он возвращает целое число, показывая сколько монет было предоставлено.
- Метод `receive(coins:)` просто добавляет полученное число монет обратно в банк.

Класс `Player` описывает игрока в игре. Каждый игрок имеет определенное количество монет, хранящихся для любых целей, которые могут быть использованы в любое время. Это отображается свойством `coinsInPurse`:

```swift
class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.distribute(coins: coins)
    }
    func win(coins: Int) {
        if coinsInPurse >= 0 {
            coinsInPurse += Bank.distribute(coins: coins)
        } else if coinsInPurse <= -coins {
            coinsInPurse += coins
        } else {
            coinsInPurse = Bank.distribute(coins: coins + coinsInPurse)
        }
    }
    func loss(coins: Int) {
        if coinsInPurse >= coins {
            Bank.receive(coins: coins)
        } else {
            Bank.receive(coins: coinsInPurse)
        }
        coinsInPurse -= coins
    }
    deinit {
        Bank.receive(coins: coinsInPurse)
    }
}
```

Каждый экземпляр `Player` инициализирован с начальным допущением определенного количества монет из банка, хотя `Player` может получить и меньшее количество монет, если недостаточно монет в банке.

Класс `Player` определяет метод `win(coins:)`, который получает определенное число монет от банка и добавляет их в кошелек игрока.

Класс `Player` определяет метод `loss(coins: Int)`, который возвращает определенное число монет в банк и вычитает их из кошелка игрока. Если у игрока меньше монет, чем необходимо вернуть в банк, то он возвращает все свои монеты в банк, а в свойстве `coinsInPurse` указывается отрицательный баланс.

Класс `Player` так же реализует деинициализатор, который вызывается сразу после того, как экземпляр освобождается.

В примере ниже деинициализатор просто возвращает все монеты игрока в банк:

```swift
var playerOne: Player? = Player(coins: 100)
print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")

// Output
// A new player has joined the game with 100 coins

print("There are now \(Bank.coinsInBank) coins left in the bank")

// Output
// There are now 9900 coins left in the bank
```

Новый экземпляр `Player` создан со `100` монетами, если такое количество есть в банке. Экземпляр хранит опциональную переменную `playerOne` типа `Player`. Опциональный тип используется здесь, поскольку игрок может покинуть игру в любой момент. Опционал позволяет отслеживать присутствие игрока в игре.

Так как `playerOne` является опциональным, то используем восклицательный знак (`!`), когда необходимо получить доступ к его свойству `coinsInPurse` или когда вызываются методы `winCoins(_:)`, `loss(_:)`:

```swift
playerOne!.loss(coins: 1100)
print("PlayerOne loss 1100 coins & now has \(playerOne!.coinsInPurse) coins")

// Output
// PlayerOne loss 1100 coins & now has -1000 coins

print("The bank now only has \(Bank.coinsInBank) coins left")

// Output
// The bank now only has 10000 coins left

playerOne!.win(coins: 500)
print("PlayerOne won 500 coins & now has \(playerOne!.coinsInPurse) coins")

// Output
// PlayerOne won 500 coins & now has -500 coins

print("The bank now only has \(Bank.coinsInBank) coins left")

// Output
// The bank now only has 10000 coins left

playerOne!.win(coins: 600)
print("PlayerOne won 600 coins & now has \(playerOne!.coinsInPurse) coins")

// Output
// PlayerOne won 600 coins & now has 100 coins

print("The bank now only has \(Bank.coinsInBank) coins left")

// Output
// The bank now only has 9900 coins left

playerOne!.win(coins: 2_000)
print("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")

// Output
// PlayerOne won 2000 coins & now has 2100 coins

print("The bank now only has \(Bank.coinsInBank) coins left")

// Output
// The bank now only has 7900 coins left
```

Здесь 
- игрок проиграл `1100` монет. У него в кошельке `-1000` монет (должен в банк). В банк перешла вся сумма из его кошелька - `100` и в банке осталось `10000` монет;
- игрок выиграл `500` монет. Эта сумма не превышает его долг, а это значит, что в банке количество монет не меняется. Теперь у него в кошельке `-500` монет (должен в банк). соответственно, в банке осталось `10000` монет;
- игрок выиграл `600` монет. Эта сумма больше его долга в банк, соответственно разницу он берет из банка в свой кошелёк. Теперь у него в кошельке `100` монет, соответственно, в банке осталось `9900` монет;
- игрок выиграл `2000` монет. Теперь у него в кошельке `2100` монет, соответственно, в банке осталось `7900` монет.

```swift
playerOne = nil
print("PlayerOne has left the game")

// Output
// PlayerOne has left the game

print("The bank now has \(Bank.coinsInBank) coins")

// Output
// The bank now has 10000 coins
```

Игрок покинул игру. Это осуществимо, если присвоим опционалу `playerOne` значение `nil`, что значит, что игрока больше нет.

На этот момент у нас больше нет доступа к свойствам или методам переменной `playerOne`, то есть у нас не стало ссылки на экземпляр класса `Player`, так что экземпляр освобождается и освобождается память. Прямо перед тем как это случится, автоматически вызывается деинициализатор, который возвращает монеты в банк.

---

## Еще полезные ссылки

- [Переменные и константы](https://robot.obo.dev/read/posts/variable/)
- [Типы данных](https://robot.obo.dev/read/posts/data-type/)
- [Опционалы](https://robot.obo.dev/read/posts/optional-data-type/)
- [Функции](https://robot.obo.dev/read/posts/function/)
- [Замыкания](https://robot.obo.dev/read/posts/closure/)
- [Перечисления](https://robot.obo.dev/read/posts/enum/)
- [Структуры](https://robot.obo.dev/read/posts/structure/)
- [Классы](https://robot.obo.dev/read/posts/class/)

Также информацию по инициализации и деинициализации можно получить на странице официальной документации.

Ссылки на официальную документацию:

- [Swift.org - Initialization](https://docs.swift.org/swift-book/LanguageGuide/Initialization.html)
- [Swift.org - Deinitialization](https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html)